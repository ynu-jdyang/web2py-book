## 视图
``views``:inxx ``template language``:inxx ``HTML``:inxx

web2py使用Python模型，控制器和视图，虽然在视图中它使用略作修改的Python语法使代码更具可读性，而不对适当的Python施加任何限制。
视图的目的是在HTML文档中嵌入代码（Python）。在一般情况下，这带来了一些问题：

- 如何转义嵌入的代码？
- 缩进应根据Python还是HTML规则？

web2py使用 ``{{ ... }}`` 转义嵌入在HTML中的Python代码。使用大括号而不是尖括号的优势是，它对所有常见的HTML编辑器是透明的。这使开发人员可以使用
这些编辑器创建web2py视图。

由于开发人员将Python代码嵌入到HTML中，该文件的缩进应根据HTML规则而不是Python规则。因此，在``{{...}}``标签内我们允许不缩进的Python。因为Python通常使用缩进来分隔代码块，我们需要以不同的方式来分隔它们，这就是web2py模板语言使用Python关键字 ``pass``的原因。 

-------
一个代码块开始与一行以冒号结束的代码并且结束于一行以``pass``开始的代码。在上下文中，代码块的结尾显而易见时，关键字``pass``是没有必要的。
-------

下面是一个例子：

``
{{
if i == 0:
response.write('i is 0')
else:
response.write('i is not 0')
pass
}}
``:code

需要注意的是``pass``是一个Python关键字，而不是web2py关键字。一些Python编辑器，比如Emacs，使用关键字``pass``来表示块的划分并用它来重新自动缩进代
码。

web2py模板语言实现的功能是一样的。当它发现类似如下的代码时：

``
<html><body>
{{for x in range(10):}}{{=x}}hello<br />{{pass}}
</body></html>
``:code

它把代码转换成一个程序：
``
response.write("""<html><body>""", escape=False)
for x in range(10):
    response.write(x)
    response.write("""hello<br />""", escape=False)
response.write("""</body></html>""", escape=False)
``:code
``response.write`` 向``response.body``中写入。

当web2py视图中出现错误时，错误报告显示了生成的视图代码，而不是开发者编写的实际的视图。通过突出显示实际执行的代码（该代码可以用HTML编辑器或浏览器的DOM督察来调试）帮助开发者调试代码。

还要注意的是：
``
{{=x}}
``:code

生成
``response.write``:inxx ``escape``:inxx
``
response.write(x)
``:code

默认情况下，这样注入HTML中的变量被转义。如果``x`` 是一个 ``XML`` 对象，转义被忽略，即使转义设置为``True``。

下面是一个介绍 ``H1``帮助对象的例子：
``
{{=H1(i)}}
``:code

它被转换成：
``
response.write(H1(i))
``:code

评估完成后，``H1``对象和它的组成部分被递归地序列化，转义，并写入到响应主体中。由``H1``和内部HTML生成的标签不被转义。这种机制保证了在网页上显示的所有文字--- 只有文字 ---  总是得到转义，从而防止XSS漏洞。同时，代码简单且易于调试。

方法 ``response.write(obj, escape=True)`` 有两个参数，要写入的对象以及它是否要进行转义（默认设置为``True``）。如果``obj``有``.xml()``方法，它被调用并将结果写入到响应主体（``escape``参数被忽略）。否则，它使用对象的``__str__`` 的方法将其序列化，如果转义参数是``True``，对其进行转义。所有内置帮助对象（例子中是``H1`` ）知道如何通过``.xml()``方法对自身进行序列化。

这都是透明完成的。你永远不需要（而且永远不应该）显式调用``response.write`` 方法。

### 基本语法

web2py模板语言支持所有的Python控制结构。在这里我们每个结构提供一些例子。可以根据通常的编程实践嵌套它们。

#### ``for...in``
``for``:inxx

在模板中你可以循环任何迭代对象：
``
{{items = ['a', 'b', 'c']}}
<ul>
{{for item in items:}}<li>{{=item}}</li>{{pass}}
</ul>
``:code

这会产生
``
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
``:code

这里``item``是任意可迭代对象，如Python列表，Python元组，或Rows对象，或任何作为迭代器来实现的对象。首先序列化和转义要显示的元素。 

#### ``while``
``while``:inxx

你可以使用while关键字创建循环：
``
{{k = 3}}
<ul>
{{while k > 0:}}<li>{{=k}}{{k = k - 1}}</li>{{pass}}
</ul>
``:code

这会产生；
``
<ul>
<li>3</li>
<li>2</li>
<li>1</li>
</ul>
``:code

#### ``if...elif...else``
``if``:inxx ``elif``:inxx ``else``:inxx

你可以使用条件从句：
``
{{
import random
k = random.randint(0, 100)
}}
<h2>
{{=k}}
{{if k % 2:}}is odd{{else:}}is even{{pass}}
</h2>
``:code

这会产生：
``
<h2>
45 is odd
</h2>
``:code

因为很明显，``else``关闭了第一个``if``块，没有必要使用``pass``语句，并且使用将是不正确的。但是，你必须使用``pass``明确地关闭 ``else``块。

回想一下，Python中的"else if"是写成``elif`` 正如在下面的例子中：
``
{{
import random
k = random.randint(0, 100)
}}
<h2>
{{=k}}
{{if k % 4 == 0:}}is divisible by 4
{{elif k % 2 == 0:}}is even
{{else:}}is odd
{{pass}}
</h2>
``:code

它会产生：
``
<h2>
64 is divisible by 4
</h2>
``:code

#### ``try...except...else...finally``
``try``:inxx ``except``:inxx ``else``:inxx ``finally``:inxx

也可以使用``try...except`` 语句但有一点需要注意。请看下面的例子：
``
{{try:}}
Hello {{= 1 / 0}}
{{except:}}
division by zero
{{else:}}
no division by zero
{{finally}}
<br />
{{pass}}
``:code

它将产生以下输出：
``
Hello
division by zero
<br />
``:code

这个例子说明，在异常发生之前产生的所有输出（包括异常之前的输出）在try块中呈现。“Hello”被编写是因为它在异常之前。

#### ``def...return``
``def``:inxx ``return``:inxx

web2py模板语言允许开发人员定义和实现可以返回任何Python对象或text/html字符串的函数。在这里，我们来看两个例子：
``
{{def itemize1(link): return LI(A(link, _href="http://" + link))}}
<ul>
{{=itemize1('www.google.com')}}
</ul>
``:code

产生如下输出：
``
<ul>
<li><a href="http:/www.google.com">www.google.com</a></li>
</ul>
``:code

函数能``itemize1``返回一个插入在函数调用位置的帮助对象。 

现在考虑下面的代码：
``
{{def itemize2(link):}}
<li><a href="http://{{=link}}">{{=link}}</a></li>
{{return}}
<ul>
{{itemize2('www.google.com')}}
</ul>
``:code

它产生与上述完全相同的输出。在这种情况下，函数``itemize2``代表一段要在函数调用位置取代web2py标记的HTML。请注意，``itemize2``调用前面没有'='，因为该函数不返回文本，而是直接将它写入到响应中。

有一点需要注意：视图中定义的函数必须用一个return语句终止，否则自动缩进会失败。

### HTML帮助对象
``helpers``:inxx

考虑下面视图中的代码：
``
{{=DIV('this', 'is', 'a', 'test', _id='123', _class='myclass')}}
``:code

它被呈现为：
``
<div id="123" class="myclass">thisisatest</div>
``:code
``DIV`` 是一个帮助对象类，即可以用来编程的建立HTML的东西。它对应于HTML的 ``<div>`` 标签。

位置参数被解释为包含在open和close标签之间的对象。以下划线开头的命名参数被解释为HTML标签的属性（不再带下划线）。一些帮助对象也有不以下划
线开始的命名参数，这些参数是特定于标记的。

除了一组命名参数之外，帮助对象也可以使用``*`` 符号接收一个单独的列表或元组作为自己的一套组件，并且它可以使用``**``接收单一的字典作为属性组，例
如：
``
{{
contents = ['this','is','a','test']
attributes = {'_id':'123', '_class':'myclass'}
=DIV(*contents,**attributes)
}}
``:code
（产生与之前相同的输出）。

以下帮助对象集：

``A``,  ``B``,  ``BEAUTIFY``,  ``BODY``,  ``BR``,  ``CAT``,  ``CENTER``,  ``CODE``,  ``COL``, ``COLGROUP``, ``DIV``,  ``EM``,  ``EMBED``,  ``FIELDSET``,  ``FORM``,  ``H1``,  ``H2``,  ``H3``,  ``H4``,  ``H5``,  ``H6``,  ``HEAD``,  ``HR``,  ``HTML``,  ``I``,  ``IFRAME``,  ``IMG``,  ``INPUT``,  ``LABEL``,  ``LEGEND``,  ``LI``,  ``LINK``,  ``MARKMIN``,  ``MENU``,  ``META``,  ``OBJECT``,  ``ON``,  ``OL``,  ``OPTGROUP``,  ``OPTION``,  ``P``,  ``PRE``,  ``SCRIPT``,  ``SELECT``,  ``SPAN``,  ``STYLE``,  ``TABLE``,  ``TAG``,  ``TBODY``,  ``TD``,  ``TEXTAREA``,  ``TFOOT``,  ``TH``,  ``THEAD``,  ``TITLE``,  ``TR``,  ``TT``, ``UL``,   ``URL``,  ``XHTML``,  ``XML``,  ``embed64``,  ``xmlescape``

可以用于构建复杂的表达式，该表达式之后被序列化成XML``xml-w``:cite ``xml-o``:cite。例如：
``
{{=DIV(B(I("hello ", "<world>"))), _class="myclass")}}
``:code

被呈现为：
``
<div class="myclass"><b><i>hello &lt;world&gt;</i></b></div>
``:code

帮助对象也可以被序列化为字符串，与使用``__str__`` 和 ``xml`` 方法是等价的：

``
>>> print str(DIV("hello world"))
<div>hello world</div>
>>> print DIV("hello world").xml()
<div>hello world</div>
``

``Document Object Model (DOM)``:inxx
在web2py中的帮助对象机制不仅是一个无需连接字符串即可生成HTML的系统。它提供了一个文档对象模型（DOM）的服务器端表示。

可以通过位置引用帮助对象的组件，并且从组件的角度看，帮助对象的行为类似列表：
``
>>> a = DIV(SPAN('a', 'b'), 'c')
>>> print a
<div><span>ab</span>c</div>
>>> del a[1]
>>> a.append(B('x'))
>>> a[0][0] = 'y'
>>> print a
<div><span>yb</span><b>x</b></div>
``:code

帮助对象的属性可以通过名称引用，而且从属性的角度看，帮助对象的行为类似于字典：
``
>>> a = DIV(SPAN('a', 'b'), 'c')
>>> a['_class'] = 's'
>>> a[0]['_class'] = 't'
>>> print a
<div class="s"><span class="t">ab</span>c</div>
``:code

注意，可以通过称为``a.components``的列表访问完整的组件集，并且可以通过称为``a.attributes``的字典访问完整属性集。所以，当 ``i``是整数时``a[i]`` 相当于``a.components[i]``，并且当``s``是字符串时``a[s]``相当于 ``a.attributes[s]`` 。

注意帮助对象属性作为关键字参数传递给帮助对象。然而，在一些情况下，属性名称中包含Python标识符不允许的特殊字符（例如，连字符），因此不能
被用来作为关键字参数名称。例如：

``
DIV('text', _data-role='collapsible')
``:code

不会起作用，因为"_data-role"包含连字符，这将产生Python语法错误。

在这种情况下，你可以将属性作为字典传递并使用Python的``**``函数参数符号，它将（键：值）对字典映射成关键字参数集：  

``
>>> print DIV('text', **{'_data-role': 'collapsible'})
<div data-role="collapsible">text</div>
``:code

你也可以动态的创建特殊标签：

``
>>> print TAG['soap:Body']('whatever',**{'_xmlns:m':'http://www.example.org'})
<soap:Body xmlns:m="http://www.example.org">whatever</soap:Body>
``:code

#### ``XML``（可扩展标记语言）
``XML``:inxx
``XML`` 是一种用于封装不应该转义的文本的对象。文本中可以包含或不包含有效的XML。例如，它可以包含JavaScript。

在这个例子中的文本被转义：
``
>>> print DIV("<b>hello</b>")
&lt;b&gt;hello&lt;/b&gt;
``:code

你可以通过使用``XML``阻止转义： 
``
>>> print DIV(XML("<b>hello</b>"))
<b>hello</b>
``:code

有时候，你想呈现存储在变量中的HTML，但该HTML可能包含不安全的标记例如脚本：
``
>>> print XML('<script>alert("unsafe!")</script>')
<script>alert("unsafe!")</script>
``:code

类似未转义的可执行输入（例如，在博客评论的主体中输入）是不安全的，因为它可以被用来生成跨站点脚本（XSS）攻击该页面的其它游客。

``sanitize``:inxx
web2py的``XML``帮助对象可以净化我们的文本，以防止注入并转义所有标签，除了那些明确允许的。下面是一个例子：
``
>>> print XML('<script>alert("unsafe!")</script>', sanitize=True)
&lt;script&gt;alert(&quot;unsafe!&quot;)&lt;/script&gt;
``:code

默认情况下， ``XML`` 的构造函数认为一些标签的内容和一些属性是安全的。你可以使用可选参数``permitted_tags``和``allowed_attributes``重写默认值。下面是``XML`` 帮助对象可选参数的默认值。
``
XML(text, sanitize=False,
    permitted_tags=['a', 'b', 'blockquote', 'br/', 'i', 'li',
       'ol', 'ul', 'p', 'cite', 'code', 'pre', 'img/'],
    allowed_attributes={'a':['href', 'title'],
       'img':['src', 'alt'], 'blockquote':['type']})
``:code

#### 内置帮助对象

##### ``A``

该帮助对象用于创建链接。

``A``:inxx
``
>>> print A('<click>', XML('<b>me</b>'),
            _href='http://www.web2py.com')
<a href='http://www.web2py.com'>&lt;click&gt;<b>me/b></a>
``:code

除了``_href`` ，你可以使用``callback`` 参数传递URL。例如在一个视图中：

``
{{=A('click me', callback=URL('myaction'))}}
``

按下链接的效果将是对"myaction"的一个ajax调用，而不是重定向。在这种情况下，你可以可选的指定两个参数： ``target`` 和 ``delete``:
``
{{=A('click me', callback=URL('myaction'), target="t")}}
<div id="t"><div>
``
并且ajax回调的响应将被存储在id等于"t" 的DIV中。

``
<div id="b">{{=A('click me', callback=URL('myaction'), delete='div#b")}}</div>
``
响应之后，匹配"div#b"的最接近的标记将被删除。在这种情况下，该按钮将被删除。一个典型的应用是：

``
{{=A('click me', callback=URL('myaction'), delete='tr")}}
``

在一个表中。按下按钮将要执行回调并删除表的行。
callback和delete可以结合起来。

``callback`` and ``delete`` can be combined.

帮助对象A带一个称为``cid``的特殊参数。它的工作原理如下：

``
{{=A('linked page', _href='http://example.com', cid='myid')}}
<div id="myid"></div>
``:code

并且点击链接会导致内容被加载在div中。这类似于上面的语法但是更强大，因为它是专门用来刷新页面组件的。第12章我们将在组件的上下文中更详细的讨
论``cid``的应用。 

这些ajax功能需要jQuery和"static/js/web2py_ajax.js"，通过在布局头中放置 ``{{include 'web2py_ajax.html'}}`` ，它们会被自动包含。
“views/web2py_ajax.html”定义了一些基于``request`` 的变量并且包括所有必要的js和css文件。


##### ``B``
``B``:inxx

这个帮助对象使其内容加粗。
``
>>> print B('<hello>', XML('<i>world</i>'), _class='test', _id=0)
<b id="0" class="test">&lt;hello&gt;<i>world</i></b>
``:code

##### ``BODY``
``BODY``:inxx
该帮助对象创建页面主体。
``
>>> print BODY('<hello>', XML('<b>world</b>'), _bgcolor='red')
<body bgcolor="red">&lt;hello&gt;<b>world</b></body>
``:code

##### ``BR``
``BR``:inxx

This helper creates a line break.
``
>>> print BR()
<br />
``:code

##### ``CAT`` (1.98.1 and up)
``CAT``:inxx

这个帮助对象连接其它帮助对象，像TAG['']一样。 
``
>>> print CAT('Here is a ', A('link',_href=URL()), ', and here is some ', B('bold text'), '.')
Here is a <a href="/app/default/index">link</a>, and here is some <b>bold text</b>.
``:code

##### ``CENTER``
``CENTER``:inxx

该帮助对象使其内容居中。
``
>>> print CENTER('<hello>', XML('<b>world</b>'),
>>>              _class='test', _id=0)
<center id="0" class="test">&lt;hello&gt;<b>world</b></center>
``:code

##### ``CODE``
``CODE``:inxx

该帮助对象为Python，C，C++，HTML和web2py代码执行语法高亮显示，并且最好为代码清单使用``PRE``。``CODE``也有能力创建链接到web2py的API文档。  

下面是一个高亮显示部分Python代码的例子。
``
>>> print CODE('print "hello"', language='python').xml()
<table><tr valign="top"><td style="width:40px; text-align: right;"><pre style="
        font-size: 11px;
        font-family: Bitstream Vera Sans Mono,monospace;
        background-color: transparent;
            margin: 0;
            padding: 5px;
            border: none;
        background-color: #E0E0E0;
        color: #A0A0A0;
    ">1.</pre></td><td><pre style="
        font-size: 11px;
        font-family: Bitstream Vera Sans Mono,monospace;
        background-color: transparent;
            margin: 0;
            padding: 5px;
            border: none;
            overflow: auto;
    "><span style="color:#185369; font-weight: bold">print </span>
    <span style="color: #FF9966">"hello"</span></pre></td></tr>
</table>
``:code

下面是一个类似的HTML的例子
``
>>> print CODE(
>>>   '<html><body>{{=request.env.remote_add}}</body></html>',
>>>   language='html')
``:code
``
<table>...<code>...
<html><body>{{=request.env.remote_add}}</body></html>
...</code>...</table>
``:code

这是``CODE``帮助对象的默认参数：
``
CODE("print 'hello world'", language='python', link=None, counter=1, styles={})
``:code

 ``language`` 参数支持的语言的值是"python", "html_plain", "c", "cpp", "web2py", 及"html"。 "html"语言会把{{ and }}标签解释为“web2py”代码，，而
“html_plain”不会。

如果指定 ``link`` 的值，例如"/examples/global/vars/"，代码中的web2py API引用链接到URL链接处的文档。例如"request"将被链接到"/examples/global/vars/request"。在上述的例子中，链接由"global.py"控制器中的"vars" 动作处理看，"global.py"控制器作为web2py的 "examples"应用的部分发布。

``counter`` 参数用于行编号。它可以被设置为三个不同值中的任意一个。它可以是没有行号时的 ``None`` ，或一个指定起始号码的数值，或一个字符串。如果计数器设
置为一个字符串，它被解释为提示，并且没有行号。

 ``styles`` 参数有点棘手。如果你看一下上面生成的HTML，它包含一个有两列的表，每列都有自己的使用CSS声明为inline的样式。``styles``属性允许你覆盖这两个CSS
样式。例如：

``
{{=CODE(...,styles={'CODE':'margin: 0;padding: 5px;border: none;'})}}
``:code

``styles`` 属性必须是一个字典，并且它允许两个可能的密钥：``CODE`` 实际代码样式和``LINENUMBERS``左边列的样式，其中包含的行号。记住，这些样式完全替换默认样式而不是简单地添加到它们。

##### ``COL``
``COL``:inxx

``
>>> print COL('a','b')
<col>ab</col>
``:code

##### ``COLGROUP``
``COLGROUP``:inxx

``
>>> print COLGROUP('a','b')
<colgroup>ab</colgroup>
``:code

##### ``DIV``
除了``XML``之外的所有帮助对象均来自``DIV``并继承它的基本方法。 

``DIV``:inxx
``
>>> print DIV('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<div id="0" class="test">&lt;hello&gt;<b>world</b></div>
``:code

##### ``EM``

强调它的内容。

``EM``:inxx
``
>>> print EM('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<em id="0" class="test">&lt;hello&gt;<b>world</b></em>
``:code

##### ``FIELDSET``
``FIELDSET``:inxx

这用来创建一个输入字段连同它的标签。
``
>>> print FIELDSET('Height:', INPUT(_name='height'), _class='test')
<fieldset class="test">Height:<input name="height" /></fieldset>
``:code

##### ``FORM``
``FORM``:inxx

这是最重要的帮助工具之一。其形式简单，它只是一个 ``<form>...</form>`` 标签，但因为帮助对象时对象并且知道其所包含的内容，它们可以处理提交的表单
（例如，执行字段验证）。这将在第7章中详细讨论。
``
>>> print FORM(INPUT(_type='submit'), _action='', _method='post')
<form enctype="multipart/form-data" action="" method="post">
<input type="submit" /></form>
``:code

默认情况下，"enctype" 是“multipart / form-data”。

``hidden``:inxx
 ``FORM``的构造函数及 ``SQLFORM``也可以接收一个特殊参数。一本字典传递时，其项目被翻译成``hidden``的INPUT字段。例如：
``
>>> print FORM(hidden=dict(a='b'))
<form enctype="multipart/form-data" action="" method="post">
<input value="b" type="hidden" name="a" /></form>
``:code

##### ``H1``, ``H2``, ``H3``, ``H4``, ``H5``, ``H6``
``H1``:inxx

这些帮助对象用于段落标题和副标题：
``
>>> print H1('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<h1 id="0" class="test">&lt;hello&gt;<b>world</b></h1>
``:code

##### ``HEAD``

用于标记HTML页面的标题。

``HEAD``:inxx
``
>>> print HEAD(TITLE('<hello>', XML('<b>world</b>')))
<head><title>&lt;hello&gt;<b>world</b></title></head>
``:code

##### ``HTML``
``HTML``:inxx ``XHTML``:inxx

T这个帮助对象有点不同。除了作出 ``<html>`` 标签以外，它使用文档类型的字符串``xhtml-w,xhtml-o,xhtml-school``:添加标签。
``
>>> print HTML(BODY('<hello>', XML('<b>world</b>')))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html4/loose.dtd">
<html><body>&lt;hello&gt;<b>world</b></body></html>
``:code

HTML帮助对象还需要一些额外的具有以下默认的可选参数：
``
HTML(..., lang='en', doctype='transitional')
``:code

这里doctype可以是'strict', 'ransitional', 'frameset','html5'或一个完整的doctype字符串。

##### ``XHTML``
``XHTML``:inxx

XHTML与HTML类似，但它创建的是XHTML文档类型。
``
XHTML(..., lang='en', doctype='transitional', xmlns='http://www.w3.org/1999/xhtml')
``:code

这里doctype可以是'strict','ransitional','frameset','html5'
或一个完整的doctype字符串。

##### ``HR``
``HR``:inxx

这个帮助对象在HTML页面中创建一条水平线
``
>>> print HR()
<hr />
``:code

##### ``I``
``I``:inxx

该帮助对象将其内容设为斜体。
``
>>> print I('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<i id="0" class="test">&lt;hello&gt;<b>world</b></i>
``:code

##### ``INPUT``
``INPUT``:inxx

创建一个``<input.../>``标签。输入标签不能包含其它标签，并使用``/>``而不是``>``关闭。TINPUT标签有一个可选属性``_type``，可以设置为"text"（默认值），"submit","checkbox",或"radio"。
``
>>> print INPUT(_name='test', _value='a')
<input value="a" name="test" />
``:code

它也有一个可选的特殊的参数，称为"value"与“_value”不同。后者设置输入字段的默认值，前者设置其当前值。对于一个"text"类型的输入，前者凌驾于后者：
``
>>> print INPUT(_name='test', _value='a', value='b')
<input value="b" name="test" />
``:code

对于单选按钮，``INPUT`` 可选择设置“checked”属性： 

``radio``:inxx
``
>>> for v in ['a', 'b', 'c']:
>>>     print INPUT(_type='radio', _name='test', _value=v, value='b'), v
<input value="a" type="radio" name="test" /> a
<input value="b" type="radio" checked="checked" name="test" /> b
<input value="c" type="radio" name="test" /> c
``:code

复选框是类似的：

``checkbox``:inxx
``
>>> print INPUT(_type='checkbox', _name='test', _value='a', value=True)
<input value="a" type="checkbox" checked="checked" name="test" />
>>> print INPUT(_type='checkbox', _name='test', _value='a', value=False)
<input value="a" type="checkbox" name="test" />
``:code

##### ``IFRAME``

这个帮助对象在当前页面中包含另一个网页。另一页面的url通过“_src”属性指定。

``IFRAME``:inxx
``
>>> print IFRAME(_src='http://www.web2py.com')
<iframe src="http://www.web2py.com"></iframe>
``:code

##### ``IMG``
``IMG``:inxx

它可以用来在HTML中嵌入图像：

``
>>> IMG(_src='http://example.com/image.png',_alt='test')
<img src="http://example.com/image.ong" alt="rest" />
``:code

下面是A，IMG和包括静态图像链接的URL帮助对象的组合：

``
>>> A(IMG(_src=URL('static','logo.png'), _alt="My Logo"),
      _href=URL('default','index'))
<a href="/myapp/default/index">
  <img src="/myapp/static/logo.png" alt="My Logo" />
</a>
``:code

##### ``LABEL``

它用于为INPUT字段创建一个LABEL标签。

``LABEL``:inxx
``
>>> print LABEL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<label id="0" class="test">&lt;hello&gt;<b>world</b></label>
``:code

##### ``LEGEND``

它用于为表单中的字段创建一个legend标签。

``LEGEND``:inxx
``
>>> print LEGEND('Name', _for='myfield')
<legend for="myfield">Name</legend>
``:code

##### ``LI``

它创建一个项目列表，并应包含在``UL``或``OL`` 标记中。

``LI``:inxx
``
>>> print LI('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<li id="0" class="test">&lt;hello&gt;<b>world</b></li>
``:code

##### ``META``

用于在``HTML`` 头中创建``META`` 标签。例如：

``META``:inxx
``
>>> print META(_name='security', _content='high')
<meta name="security" content="high" />
``:code

##### ``MARKMIN``

实现的markmin的wiki语法。它根据下面例子中描述的markmin规则，将输入文本转换成输出html：

``MARKMIN``:inxx
``
>>> print MARKMIN("this is **bold** or ''italic'' and this [[a link http://web2py.com]]")
<p>this is <b>bold</b> or <i>italic</i> and
this <a href="http://web2py.com">a link</a></p>
``:code

这个web2py附带的文件中描述了markmin语法：
``
http://127.0.0.1:8000/examples/static/markmin.html
``:code

在第12章中有一些plugin_wiki上下文中的示例，它广泛使用MARKMIN。

你可以使用markmin生成HTML，LaTeX和PDF文件：

``
m = "Hello **world** [[link http://web2py.com]]"
from gluon.contrib.markmin.markmin2html import markmin2html
print markmin2html(m)
from gluon.contrib.markmin.markmin2latex import markmin2latex
print markmin2latex(m)
from gluon.contrib.markmin.markmin2pdf import markmin2pdf
print markmin2pdf(m) # requires pdflatex
``

（``MARKMIN`` 帮助对象是 ``markmin2html``的一个快捷方式）

这是一个基本的语法底漆：

--------------------------------------------------
**SOURCE**                 | **OUTPUT**
``# title``                | **title**
``## section``             | **section**
``### subsection``         | **subsection**
``**bold**``               | **bold**
``''italic''``             | ''italic''
``!`!`verbatim`!`!``       | ``verbatim``
``http://google.com``      | http://google.com
``http://...`` | ``<a href="http://...">http:...</a>``
``http://...png`` | ``<img src="http://...png" />``
``http://...mp3`` | ``<audio src="http://...mp3"></audio>``
``http://...mp4`` | ``<video src="http://...mp4"></video>``
``qr:http://...`` | ``<a href="http://..."><img src="qr code"/></a>``
``embed:http://...`` | ``<iframe src="http://..."></iframe>``
``[[click me #myanchor]]`` | [[click me #myanchor]]
``$````$\int_a^b sin(x)dx$````$``  | $$\int_a^b sin(x)dx$$
---------------------------------------------------

只需包括一个没有标记的到图像视频或音频文件的链接，相应的图像，视频或音频文件就会被自动包括（对于音频和视频，它使用HTML<audio>和<video>
标签）。

添加一个带有``qr:`` 前缀的链接，例如 

``
qr:http://web2py.com
``

导致相应的QR码被嵌入并链接到所述的URL。

添加一个链接标题 ``embed:`` 的前缀，例如：

``
embed:http://www.youtube.com/embed/x1w8hKTJ2Co
`` 

导致页面被嵌入，在这个例子中嵌入了一个youtube视频。

也可以使用下面的语法嵌入图像：

``
[[image-description http://.../image.png right 200px]]
``

无序列表使用：
``
- one
- two
- three
``

有序列表使用：
``
+ one
+ two
+ three
``

表使用：
``
----------
 X | 0 | 0
 0 | X | 0
 0 | 0 | 1
----------
``

MARKMIN语法也支持引用文字，HTML5音频和视频标签，图像对齐，自定义CSS，并且它可以扩展：

``
MARKMIN("!`!!`!abab!`!!`!:custom", extra=dict(custom=lambda text: text.replace('a','c'))
``:code

生成

``'cbcb'``:code

自定义块用``!`!!`!...!`!!`!:<key>``分隔并且它们被函数呈现，该函数作为值传递给MARKMIN的额外字典参数。注意，该函数可能需要转义输出，以防止XSS。

##### ``OBJECT``

用于在HTML中嵌入对象（例如，一个flash播放器）。

``OBJECT``:inxx
``
>>> print OBJECT('<hello>', XML('<b>world</b>'),
>>>              _src='http://www.web2py.com')
<object src="http://www.web2py.com">&lt;hello&gt;<b>world</b></object>
``:code

##### ``OL``

它代表了有序列表。该列表应包含LI标签。不是``LI`` 对象的``OL`` 参数会被自动包含在 ``<li>...</li>`` 标签中。

``OL``:inxx
``
>>> print OL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<ol id="0" class="test"><li>&lt;hello&gt;</li><li><b>world</b></li></ol>
``:code

##### ``ON``

这是为了向后兼容，它只是``True``的一个别名。它专门用于复选框并且已经被废弃了，因为``True`` 更加Python。

``ON``:inxx
``
>>> print INPUT(_type='checkbox', _name='test', _checked=ON)
<input checked="checked" type="checkbox" name="test" />
``:code

##### ``OPTGROUP``

允许你在一个SELECT中组合多个选项并且它在使用CSS自定义字段时是有用的。

``OPTGROUP``:inxx
``
>>> print SELECT('a', OPTGROUP('b', 'c'))
<select>
  <option value="a">a</option>
  <optgroup>
    <option value="b">b</option>
    <option value="c">c</option>
  </optgroup>
</select>
``:code

##### ``OPTION``

这应该只作为SELECT/ OPTION组合的一部分被使用。

``OPTION``:inxx
``
>>> print OPTION('<hello>', XML('<b>world</b>'), _value='a')
<option value="a">&lt;hello&gt;<b>world</b></option>
``:code

至于``INPUT``的情况，web2py区分"_value"（OPTION的值）和"value"（封闭选择
的当前值）。如果它们是平等的，option被选择。

``selected``:inxx
``
>>> print SELECT('a', 'b', value='b'):
<select>
<option value="a">a</option>
<option value="b" selected="selected">b</option>
</select>
``:code

##### ``P``
``P``:inxx

这用于标记一个段落。
``
>>> print P('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<p id="0" class="test">&lt;hello&gt;<b>world</b></p>
``:code

##### ``PRE``
``PRE``:inxx

生成一个 ``<pre>...</pre>``标签用于显示预格式化的文本。通常应优先为代码清单选用``CODE`` 帮助对象。
``
>>> print PRE('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<pre id="0" class="test">&lt;hello&gt;<b>world</b></pre>
``:code

##### ``SCRIPT``
``SCRIPT``:inxx

这是包括或链接脚本如JavaScript。为了真过时了的浏览器的利益，标签之间的内容呈现为HTML注释。
``
>>> print SCRIPT('alert("hello world");', _type='text/javascript')
<script type="text/javascript"><!--
alert("hello world");
//--></script>
``:code

##### ``SELECT``
``SELECT``:inxx

创建一个``<select>...</select>`` >标签。这与 ``OPTION`` 帮助对象合用。这些不是 ``OPTION``对象的 ``SELECT`` 参数被自动转换为选项。
``
>>> print SELECT('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<select id="0" class="test">
   <option value="&lt;hello&gt;">&lt;hello&gt;</option>
   <option value="&lt;b&gt;world&lt;/b&gt;"><b>world</b></option>
</select>
``:code

##### ``SPAN``
``SPAN``:inxx
 
类似``DIV``但用于标记内联（而不是块）内容。
``
>>> print SPAN('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<span id="0" class="test">&lt;hello&gt;<b>world</b></span>
``:code

##### ``STYLE``
``STYLE``:inxx

类似于脚本，但用来包含或链接CSS代码。这里的CSS包括
``
>>> print STYLE(XML('body {color: white}'))
<style><!--
body { color: white }
//--></style>
``:code

这里链接：
``
>>> print STYLE(_src='style.css')
<style src="style.css"><!--
//--></style>
``:code

##### ``TABLE``, ``TR``, ``TD``
``TABLE``:inxx ``TR``:inxx ``TD``:inxx

这些标签（以及可选的 ``THEAD``， ``TBODY`` 和 ``TFOOTER``帮助对象）用来建立HTML表格。
``
>>> print TABLE(TR(TD('a'), TD('b')), TR(TD('c'), TD('d')))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code
``TR`` 期待``TD`` 内容； 不是 ``TD`` 对象的参数被自动转换。
``
>>> print TABLE(TR('a', 'b'), TR('c', 'd'))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code

使用Python的``*``函数的参数标记能很容易的将Python数组转换成一个HTML表，它将列表中的元素映射到位置函数的参数。 

在这里，我们逐行进行：
``
>>> table = [['a', 'b'], ['c', 'd']]
>>> print TABLE(TR(*table[0]), TR(*table[1]))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code

这里我们一次完成所有行：
``
>>> table = [['a', 'b'], ['c', 'd']]
>>> print TABLE(*[TR(*rows) for rows in table])
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code

##### ``TBODY``
``TBODY``:inxx

这用来标记表的主体中包含的行，而不是页眉或页脚行。它是可选的。
``
>>> print TBODY(TR('<hello>'), _class='test', _id=0)
<tbody id="0" class="test"><tr><td>&lt;hello&gt;</td></tr></tbody>
``:code

##### ``TEXTAREA``
``TEXTAREA``:inxx

这个帮助对象创建一个 ``<textarea>...</textarea>`` 标签。
``
>>> print TEXTAREA('<hello>', XML('<b>world</b>'), _class='test')
<textarea class="test" cols="40" rows="10">&lt;hello&gt;<b>world</b></textarea>
``:code

唯一需要注意的是，可选的“value”（“值”），将覆盖其内容（内部HTML）
``
>>> print TEXTAREA(value="<hello world>", _class="test")
<textarea class="test" cols="40" rows="10">&lt;hello world&gt;</textarea>
``:code

##### ``TFOOT``
``TFOOT``:inxx

这用来标记表尾行。
``
>>> print TFOOT(TR(TD('<hello>')), _class='test', _id=0)
<tfoot id="0" class="test"><tr><td>&lt;hello&gt;</td></tr></tfoot>
``:code

##### ``TH``
``TH``:inxx

在表头中使用它来取代 ``TD`` 。
``
>>> print TH('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<th id="0" class="test">&lt;hello&gt;<b>world</b></th>
``:code

##### ``THEAD``
``THEAD``:inxx

这用来标记表头行。
``
>>> print THEAD(TR(TH('<hello>')), _class='test', _id=0)
<thead id="0" class="test"><tr><th>&lt;hello&gt;</th></tr></thead>
``:code

##### ``TITLE``
``TITLE``:inxx

这用于在HTML标头中标记页面标题。
``
>>> print TITLE('<hello>', XML('<b>world</b>'))
<title>&lt;hello&gt;<b>world</b></title>
``:code

##### ``TR``
``TR``:inxx

标记表中的一行。它应该呈现在表内，并包含``<td>...</td>``标签。不是``TD``的对象的``TR`` 参数是会被自动转换。
``
>>> print TR('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<tr id="0" class="test"><td>&lt;hello&gt;</td><td><b>world</b></td></tr>
``:code

##### ``TT``
``TT``:inxx

将文本标记为打字机（等宽）文本。
``
>>> print TT('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<tt id="0" class="test">&lt;hello&gt;<b>world</b></tt>
``:code

##### ``UL``

标志着一个无序列表并应包含LI项目。如果其内容未标记为LI，UL会自动完成。

``UL``:inxx
``
>>> print UL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<ul id="0" class="test"><li>&lt;hello&gt;</li><li><b>world</b></li></ul>
``:code

##### ``embed64``

``embed64(filename=None, file=None, data=None, extension='image/gif')`` 将提供的数据（二进制）编码成base64数据。filename( 文件名)：如果提供的话，
在 'rb' 模式下打开并读取该文件。file (文件)：如果提供的话，读取该文件。data
(数据)：如果提供的话，使用提供的数据。

``embed64``:inxx

##### ``xmlescape``

``xmlescape(data, quote=True)`` 返回所提供数据的转义字符串。

``xmlescape``:inxx
``
>>> print xmlescape('<hello>')
&lt;hello&gt;
``:code

#### 自定义帮助对象

##### ``TAG``
``TAG``:inxx

有时你需要生成自定义XML标签。 web2py会提供``TAG``，一个通用标签生成器。
``
{{=TAG.name('a', 'b', _c='d')}}
``:code

生成如下XML
``
<name c="d">ab</name>
``:code

参数"a", "b", 和 "d" 被自动转义;使用``XML`` 帮助对象来抑制这种行为。使用``TAG`` 你可以生成API未提供的HTML/ XML标签。标签可以嵌套，并且使用 ``str()``。
序列化等效语法是：
``
{{=TAG['name']('a', 'b', c='d')}}
``:code

如果创建的TAG对象名称为空，可以用它来把多个字符串和HTML帮助对象连接在一起，而不需要将它们嵌入到周围标签中，但这种用法已经过时了。使用 ``CAT`` 帮助对象来取代它。

请注意， ``TAG`` 是一个对象，而且``TAG.name`` 或``TAG['name']`` 是一个函数，该函数返回一个临时的帮助对象类。

##### ``MENU``
``MENU``:inxx

MENU帮助对象接收一个列表或元组的列表，形式为``response.menu`` （正如第4章中描述的）并使用无序列表生成一个表示菜单的树状结构。例如：
``
>>> print MENU([['One', False, 'link1'], ['Two', False, 'link2']])
<ul class="web2py-menu web2py-menu-vertical">
  <li><a href="link1">One</a></li>
  <li><a href="link2">Two</a></li>
</ul>
``:code

每个菜单项可以有第四个参数，它是一个嵌套的子菜单（依此递归类推）：
``
>>> print MENU([['One', False, 'link1', [['Two', False, 'link2']]]])
<ul class="web2py-menu web2py-menu-vertical">
  <li class="web2py-menu-expand">
     <a href="link1">One</a>
     <ul class="web2py-menu-vertical">
        <li><a href="link2">Two</a></li>
     </ul>
  </li>
</ul>
``:code

MENU帮助对象用如下可选参数：
- ``_class``:默认为"web2py-menu web2py-menu-vertical"并设置其它UL元素的类。
- ``ul_class``: 默认为"web2py-menu-vertical"并设置内部UL元素的类。
- ``li_class``: 默认为"web2py-menu-expand"并设置内部LI元素的类。

``mobile``:inxx

``MENU``用一个可选参数``mobile``。当设置为``True``时，它返回一个带有全部菜单选项的``SELECT``下拉菜单和一个重定向到与选中的选项相对应页面的``onchange``属性，而不是建立一个递归的``UL``菜单结构。这被设计成菜单表示的另一个选择，它增进了在小型移动设备如手机上的可用性。 

通常情况下，使用以下语法将菜单用在布局中：

``
{{=MENU(response.menu, mobile=request.user_agent().is_mobile)}}
``

在种方式下，能自动检测移动设备并且菜单被相应的呈现。

### ``BEAUTIFY``美化
``BEAUTIFY`` 用来建立复合对象的HTML表示，包括列表、元组和字典：
``
{{=BEAUTIFY({"a": ["hello", XML("world")], "b": (1, 2)})}}
``:code
``BEAUTIFY`` 返回一个类似XML的对XML可序列化的，带有一个漂亮的构造函数参数表示。在这种情况下，如下代码的XML表示：
``
{"a": ["hello", XML("world")], "b": (1, 2)}
``:code

将呈现为：
``
<table>
<tr><td>a</td><td>:</td><td>hello<br />world</td></tr>
<tr><td>b</td><td>:</td><td>1<br />2</td></tr>
</table>
``:code

### 服务器端''DOM''和解析 
``element``:inxx ``elements``:inxx

#### ``elements``方法

DIV帮助对象以及所有派生的帮助对象提供了搜索方法 ``element``和``elements``。

``element`` 返回匹配指定条件的第一个子元素（如果没有匹配的，返回None）。

``elements`` 返回一个匹配指定条件的所有子元素的列表。

**element**和**elements**使用相同的语法来指定匹配条件，它允许三种混合和匹配的可能性：类jQuery表达式，确切属性值匹配，以及使用正则表达式匹配。

下面是一个简单的例子：
``
>>> a = DIV(DIV(DIV('a', _id='target',_class='abc')))
>>> d = a.elements('div#target')
>>> d[0][0] = 'changed'
>>> print a
<div><div><div id="target" class="abc">changed</div></div></div>
``:code

``elements`` 的未命名参数是一个字符串，其中可能包含：标签名称，之前为#的标签ID，之前是一个点的类，方括号中的属性显式值。

下面是4个通过id搜索以前的标签的等价方法：
``
>>> d = a.elements('#target')
>>> d = a.elements('div#target')
>>> d = a.elements('div[id=target]')
>>> d = a.elements('div',_id='target')
``:code

下面是4个通过class搜索以前的标签的等价方法：
``
>>> d = a.elements('.abc')
>>> d = a.elements('div.abc')
>>> d = a.elements('div[class=abc]')
>>> d = a.elements('div',_class='abc')
``:code

可以使用任何属性来定位元素（不只是``id``和``class``），其中包括多个属性（element函数可以带多个命名参数），但只返回第一个匹配的元素。  

使用jQuery语法"div#target"可以指定由空格分隔的多个搜索条件：
``
>>> a = DIV(SPAN('a', _id='t1'),DIV('b',_class='c2'))
>>> d = a.elements('span#t1, div#c2')
``:code

或等价的
``
>>> a = DIV(SPAN('a', _id='t1'),DIV('b',_class='c2'))
>>> d = a.elements('span#t1','div#c2')
``:code

如果使用name参数指定属性值，它可以是一个字符串或正则表达式：
``
>>> a = DIV(SPAN('a', _id='test123'), DIV('b',_class='c2'))
>>> d = a.elements('span', _id=re.compile('test\d{3}')
``:code

DIV帮助对象的一个特殊命名参数（及其派生）是``find``。可以用它来在标签的文本内容中指定搜索值或搜索正则表达式。例如： 
``
>>> a = DIV(SPAN('abcde'), DIV('fghij'))
>>> d = a.elements(find='bcd')
>>> print d[0]
<span>abcde</span>
``:code

或
``
>>> a = DIV(SPAN('abcde'), DIV('fghij'))
>>> d = a.elements(find=re.compile('fg\w{3}'))
>>> print d[0]
<div>fghij</div>
``:code

#### ``components``方法
下面是一个在HTML字符串中列出所有元素的例子：
``
html = TAG('<a>xxx</a><b>yyy</b>')
for item in html.components: print item
``:code

#### ``parent``方法
``parent`` 返回当前元素的父元素。
``
>>> a = DIV(SPAN('a'),DIV('b'))
>>> d = a.element('a').parent()
>>> d['_class']='abc'
>>> print a
<div class="abc"><span>a</span><div>b</div></div>
``:code

#### ``flatten``方法

扁平化方法递归地将给定元素的子元素的内容序列化为普通文本（无标签）：
``
>>> a = DIV(SPAN('this', DIV('is', B('a'))), SPAN('test'))
>>> print a.flatten()
thisisatest
``:code

可以传递一个可选参数``render``给flatten，即一个使用不同的协议呈现/简化内容的函数。下面是一个将一些标签序列化成Markmin wiki语法的例子： 
``
>>> a = DIV(H1('title'), P('example of a ', A('link', _href='#test')))
>>> from gluon.html import markmin_serializer
>>> print a.flatten(render=markmin_serializer)
## titles

example of [[a link #test]]
``:code

在写作本书的时候，我们提供 ``markmin_serializer``和``markdown_serializer``。

#### 解析

TAG对象也是一个XML/ HTML解析器。它可以读取文本并将其转换成一个树状结构的帮助对象。这使得可以用上面的API操作：
``
>>> html = '<h1>Title</h1><p>this is a <span>test</span></p>'
>>> parsed_html = TAG(html)
>>> parsed_html.element('span')[0]='TEST'
>>> print parsed_html
<h1>Title</h1><p>this is a <span>TEST</span></p>
``:code

### 页面布局
``page layout``:inxx ``layout.html``:inxx ``extent``:inxx ``include``:inxx

视图可以扩展并以树状结构包含其它视图。

例如，我们能想到的一个视图的“index.html”，扩展"layout.html" 并包括“body.html”。同时，"layout.html" 中可以包括"header.html" 和"footer.html"。

树的根就是我们所说的布局视图。就像任何其它HTML模板文件，你可以使用web2py管理界面编辑它。文件名"layout.html"仅仅是一个惯例。

这是一个最低限度的页面，它扩展"layout.html" 视图并包括"page.html"视图：

``
{{extend 'layout.html'}}
<h1>Hello World</h1>
{{include 'page.html'}}
``:code

扩展的布局文件必须包含 ``{{include}}``}指令，如下：
``
<html>
  <head>
    <title>Page Title</title>
  </head>
  <body>
    {{include}}
  </body>
</html>
``:code

调用视图时，扩展（布局）视图被加载，调用视图取代布局中的``{{include}}`` 指令。处理将继续递归进行，直到所有``extend``和``include``扩展都已被处理。生成的模板之后被翻译成Python代码。请注意，当一个应用是字节码编译的，编译的是这
个Python代码，而不是原视图文件本身。因此，一个给定视图的字节码编译版本是一个single.pyc文件，其中包含的Python代码不只是原视图文件的，而是它的
整个扩展和包含视图树的。

-------
``extend``，``include``，``block`` 和 ``super`` 是特殊模板指令，而不是Python命令。
-------

 ``{{extend...}}``指令之前的任何内容或代码将在扩展视图的内容/代码之前被插入（因此被执行）。虽然这通常不用于在扩展视图的内容之前插入实际的HTML内容，它可以作为一种有用的手段，定义扩展视图可用的变量或函数。
例如，考虑一个视图"index.html"：
``
{{sidebar_enabled=True}}
{{extend 'layout.html'}}
<h1>Home Page</h1>
``:code

"layout.html"的节选：
``
{{if sidebar_enabled:}}
    <div id="sidebar">
        Sidebar Content
    </div>
{{pass}}
``:code

因为 "index.html"中 ``sidebar_enabled`` 赋值在 ``extend``之前，该行被插入在"layout.html"开始之前，使``sidebar_enabled``在"layout.html"代码内处处可用
（welcome应用使用了一个较为复杂的版本）。

还值得指出的是由控制器函数返回的变量不仅可用在函数的主视图中，而且可用在在其所有扩展和包含视图中。

 ``extend``或``include`` include（即扩展或包含的视图名称）的参数可以是一个Python变量（但不能是Python表达式）。然而，这会带来一个限制 -在``extend`` 或 ``include`` 语句中使
用变量的视图不能字节码编译。正如上面提到的，字节码编译的视图包括整个扩展和包含视图的树，所以具体的扩展及包含视图必须在编译时已知，如果视
图名称是变量（其值直到运行时才能确定）。这是不可能的，由于字节码编译视图可以提供显著的速度提升，应尽量避免在``extend`` 和 ``include`` 中使用变量。

在某些情况下，在 ``include`` 中使用变量一个替代是简单地把 ``{{include ...}}`` 指令放在 ``if...else`` 块内。

``
{{if some_condition:}}
{{include 'this_view.html'}}
{{else:}}
{{include 'that_view.html'}}
{{pass}}
``:code

字节码编译上面的代码不存在任何问题，因为未涉及任何变量。但是，请注意，字节码编译的视图实际上包括“this_view.html”和“that_view.html”的Python代
码，尽管只有其中一个视图的代码被执行，取决于``some_condition``的值。

请记住，这仅适用于 ``include`` -- 你不能把 ``{{extend ...}}`` 指令放在 ``if...else`` 块内。

``response.menu``:inxx ``menu``:inxx ``response.meta``:inxx ``meta``:inxx

布局用于封装页面共性（页眉，页脚，菜单），虽然它们不是强制性的，它们将使你的应用更容易编写和维护。特别是，我们建议编写利用以下可以在控制
器中设置的变量的布局。使用这些熟悉的变量将有助于使你的布局可互换：
``
response.title
response.subtitle
response.meta.author
response.meta.keywords
response.meta.description
response.flash
response.menu
response.files
``:code

除了``menu`` 和``files``，这些都是字符串，它们的含义应该是显而易见的。

``response.menu`` 菜单是一个3-元组或4 -元组列表。三个要素是：链接名称，一个表示链接是否处于活动状态（是否是当前链接）的布尔值和所链接页面的URL。例如：
``
response.menu = [('Google', False, 'http://www.google.com',[]),
                 ('Index',  True,  URL('index'), [])]
``:code

``sub-menu``:inxx
第四个元组元素是一个可选的子菜单。

``response.files`` 是页面需要的CSS 和 JS文件的列表。

我们还建议你使用：

``
{{include 'web2py_ajax.html'}}
``:code

在HTML头中，因为这将包括jQuery库并为特殊效果和Ajax定义一些向后兼容的JavaScript函数。“web2py_ajax.html”包括视图中的 ``response.meta`` 标签，jQuery基础，日历日期选择器，以及所有必需的CSS和JS``response.files``。

#### 默认页面布局
``superfish``:inxx ``ez.css``:inxx

以下web2py基本构建应用 **welcome**附带的"views/layout.html"（剥离一些可选部分）。任何新应用都有类似的默认布局： 

``
<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>{{=response.title or request.application}}</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="{{=request.application}}" />

  <script src="{{=URL('static','js/modernizr.custom.js')}}"></script>

  <!-- include stylesheets -->
  {{
  response.files.append(URL('static','css/skeleton.css'))
  response.files.append(URL('static','css/web2py.css'))
  response.files.append(URL('static','css/superfish.css'))
  response.files.append(URL('static','js/superfish.js'))
  }}

  {{include 'web2py_ajax.html'}}

  <script type="text/javascript">
    jQuery(function(){ jQuery('ul.sf-menu').supersubs({minWidth:12,maxWidth:30,extraWidth:3}).superfish(); });
  </script>

  {{
  # using sidebars need to know what sidebar you want to use
  left_sidebar_enabled = globals().get('left_sidebar_enabled',False)
  right_sidebar_enabled = globals().get('right_sidebar_enabled',False)
  middle_columns = {0:'sixteen',1:'twelve',2:'eight'}[
     (left_sidebar_enabled and 1 or 0)+(right_sidebar_enabled and 1 or 0)]
  }}

</head>
<body>
  <div class="wrapper"><!-- for sticky footer -->

    <div class="topbar">
      <div class="container">
        <div class="sixteen columns">
          <div id="navbar">
            {{='auth' in globals() and auth.navbar(separators=(' ',' | ',''))}}
          </div>
          <div id="menu">
            {{=MENU(response.menu, 
                    _class='mobile-menu' if is_mobile else 'sf-menu',
                    mobile=request.user_agent().is_mobile)}}
          </div>
        </div>
      </div>
    </div><!-- topbar -->

    <div class="flash">{{=response.flash or ''}}</div>

    <div class="header">
      <div class="container">
        <div class="sixteen columns">
          <h1 class="remove-bottom" style="margin-top: .5em;">
          {{=response.title or request.application}}
          </h1>
          <h5>{{=response.subtitle or ''}}</h5>
        </div>

        <div class="sixteen columns">
          <div class="statusbar">
            {{block statusbar}}
            <span class="breadcrumbs">{{=request.function}}</span>
            {{end}}
          </div>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="container">
        {{if left_sidebar_enabled:}}
        <div class="four columns left-sidebar">
          {{block left_sidebar}}
          <h3>Left Sidebar</h3>
          <p></p>
          {{end}}
        </div>
        {{pass}}

        <div class="{{=middle_columns}} columns center">
          {{block center}}
          {{include}}
          {{end}}
        </div>

        {{if right_sidebar_enabled:}}
        <div class="four columns">
          {{block right_sidebar}}
          <h3>Right Sidebar</h3>
          <p></p>
          {{end}}
        </div>
        {{pass}}

      </div><!-- container -->
    </div><!-- main -->

    <div class="push"></div>
  </div><!-- wrapper -->

  <div class="footer">
    <div class="container header">
      <div class="sixteen columns">
        {{block footer}} <!-- this is default footer -->
        <div class="footer-content" >
          {{=T('Copyright')}} &#169; 2011
          <div style="float: right;">
            <a href="http://www.web2py.com/">
            <img style="padding-bottom: 0;" 
                 src="{{=URL('static','images/poweredby.png')}}"/>
            </a>
          </div>
        </div>
        {{end}}
      </div>
    </div><!-- container -->
  </div><!-- footer -->

</body>
</html>

``:code

缺省布局有一些特征使它很容易使用和定制：

- 这是用HTML5编写的并为向后兼容性使用 ``modernizr``:cite 库。实际的布局包括一些IE浏览器要求的额外的条件语句，为了简洁起见省略了它们。
- 它显示可以设置在模型中的``response.title``和 ``response.subtitle``。如果它们都没有设置，它采用应用名作为标题
- 它包含``web2py_ajax.html`` 文件到其头部，该文件生成所有链接和脚本导入语句。
- 为了灵活布局，它使用``skeleton``:cite 的一个修改版本，它能在移动设备上运行并重新排列列以适合小型屏幕。
- 它为动态级联菜单使用"superfish.js"。有一个明确的脚本来激活superfish级联菜单并且如果没有必要的话可以删除它。
-  ``{{=auth.navbar(...)}}`` 显示欢迎当前用户以及身份验证函数链接，如登录，注销，注册，更改密码等，取决于上下文。这是一个hepler工厂并且它的输出象其它任何帮助对象一样操作。它被放置在``{{try:}}...{{except:pass}}``中，
以防auth未定义。
-  ``{{=MENU(response.menu)`` 显示菜单结构为 ``<ul>...</ul>``.
- 呈现页面时，``{{include}}`` 将被扩展视图的内容替换。
- 默认情况下它采用的是有条件的三列（左边和右边的侧边栏可以被扩展视图关闭）
- 它使用以下类：header, main, footer
- 它包含以下功能块：statusbar, left_sidebar, center, right_sidebar, footer。

如下视图可以打开并填写侧边栏：

``
{{left_sidebar_enable=True}}
{{extend 'layout.html'}}

This text goes in center

{{block left_sidebar}}
This text goes in sidebar
{{end}}
``:code

#### 定制的默认布局

``CSS``:inxx

自定义默认布局是很容易的因为CSS文件被记录：

- "skeleton.css"包含复位，网格布局，表单样式
- "web2py.css"包含特定的web2py样式
- "superfish.css"包含菜单样式

要改变颜色和背景图片，只需要将以下的代码追加到“web2py.css”：

``
body { background: url('images/background.png') repeat-x #3A3A3A; }
a { color: #349C01; }
.header h1 { color: #349C01; }
.header h2 { color: white; font-style: italic; font-size: 14px;}
.statusbar { background: #333333; border-bottom: 5px #349C01 solid; }
.statusbar a { color: white; }
.footer { border-top: 5px #349C01 solid; }
``:code

菜单以中性色彩方式建立，但你可以改变这一点。

当然，你也可以用自己的文件完全替代"layout.html" 和 "web2py.css"。

####移动部署

默认layout.html的设计是移动设备友好的，但那还不够。当页面被移动设备访问时，可能需要使用不同的视图。

为了使开发台式机和移动设备更容易，web2py中包含``@mobilize`` 装饰器。这个装饰器应用于应该有正常的视图和移动视图的动作。如下说明这一点： 

``
from gluon.contrib.user_agent_parser import mobilize 
@mobilize
def index():
   return dict()
``

请注意，在控制器中使用它之前，装饰器必须是重要的。"index"函数被普通浏览器（台式计算机）调用时，web2py会使用"[controller]/index.html"视图呈现返
回的字典。然而，由移动设备调用它时，该词典将被"[controller]/index.mobile.html"呈现。请注意，移动视图有“mobile.html”扩展
名。

另外，你可以使用下面的逻辑来使所有视图移动友好：

``
if request.user_agent().is_mobile:
    response.view.replace('.html','.mobile.html')
``

创建"*.mobile.html"的任务留给了开发者，但我们强烈建议使用"jQuery Mobile"插件，这使得任务很容易完成。

### 视图中的函数

请考虑"layout.html"：

``
<html>
  <body>
    {{include}}
    <div class="sidebar">
      {{if 'mysidebar' in globals():}}{{mysidebar()}}{{else:}}
        my default sidebar
      {{pass}}
    </div>
  </body>
</html>
``:code

与此扩展视图

``
{{def mysidebar():}}
my new sidebar!!!
{{return}}
{{extend 'layout.html'}}
Hello World!!!
``:code

注意函数定义在``{{extend...}}``语句之前--这会导致函数在"layout.html"执行之前被创建，所以可以在"layout.html"内的任意位置调用函数，
甚至在``{{include}}``之前。还要注意函数包含在扩展视图中而无需``=`` 前缀。


代码生成如下输出：

``
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my new sidebar!!!
    </div>
  </body>
</html>
``:code

请注意，该函数定义在HTML中（尽管它可能还包含Python代码）所以``response.write``用来编写它的内容（函数不返回该内容）。这就是为什么布局使
用``{{mysidebar()}}``而不是``{{=mysidebar()}}``调用视图。以这种方式定义的函数可以使用参数。

### 视图中的块
``block``:inxx

使视图更加模块化的另一种方法是通过使用``{{block...}}s``并且这种机制是上一节讨论的机制的一种替代。 

请考虑"layout.html":

``
<html>
  <body>
    {{include}}
    <div class="sidebar">
      {{block mysidebar}}
        my default sidebar
      {{end}}
    </div>
  </body>
</html>
``:code

与此扩展视图

``
{{extend 'layout.html'}}
Hello World!!!
{{block mysidebar}}
my new sidebar!!!
{{end}}
``:code

它生成的输出如下：

``
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my new sidebar!!!
    </div>
  </body>
</html>
``:code

你可以有许多块，并且如果被扩展视图中有块，但扩展视图中没有，被扩展视图的内容被使用。此外，注意到不像函数，没有必要在``{{extend ...}}`` 之前定义块--即使定义在``extend``之后，可以用它们来在被扩展视图的任意位置创建替换。

``super``:inxx

在块内，你可以使用表达式``{{super}}``来包含父内容。例如，如果我们将上述被扩展视图替换为： 

``
{{extend 'layout.html'}}
Hello World!!!
{{block mysidebar}}
{{super}}
my new sidebar!!!
{{end}}
``:code

我们得到：

``
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my default sidebar
        my new sidebar!!!
    </div>
  </body>
</html>
``:code

