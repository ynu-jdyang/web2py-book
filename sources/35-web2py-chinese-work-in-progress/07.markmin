## 表单和验证器 Forms and validators

在web2py中有四种独特的方法创建表单：
- ``FORM`` 就HTML 帮助对象，提供低级别实现。``FORM`` 对象能序列化为HTML，并知道它包含的字段。``FORM``对象知道怎样验证所提交表单的值。
- ``SQLFORM`` 提供创建的高级别API，从现存的数据库表 create（创建） 、update（更改）和delete（删除）表单。
- ``SQLFORM.factory`` 是``SQLFORM``顶端的抽象层，即使没有数据库存在也能利用表单生成特性。它从表的描述生成与``SQLFORM``非常相似的表单，无需创建
数据库表。
- ``CRUD`` 方法。这在功能上等同于SQLFORM，也基于SQLFORM，但提供更紧凑的符号。

所以这些表单是自知的，如果输入不能通过验证，它们能自己修改并增加出错消息。有关验证的变量和验证生成的出错提示，表单能被查询。
用帮助对象，任意的HTML代码，能被插入表单或从表单提出。
``FORM`` 和``SQLFORM`` 是帮助对象，能象``DIV``相似的方法操作。例如，你能设置表单风格：

``
form = SQLFORM(..)
form['_style']='border:1px solid black'
``:code

### 表单``FORM``
``form``:inxx ``accepts``:inxx ``formname``:inxx

考虑以下具有“default.py”控制器的**test** 应用的例子：
``
def display_form():
    return dict()
``:code

关联“default/display_form.html”视图：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
<form enctype="multipart/form-data"
      action="{{=URL()}}" method="post">
Your name:
<input name="name" />
<input type="submit" />
</form>
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

这是要求用户名的正则的HTML表单。当你填写表单，按了提交按钮，表单自己提交，变量 ``request.vars.name`` 和它的值显示在底部。

你能用帮助对象生成同样的表单。这能在视图或动作中完成。因为web2py在动作中处理表单，在动作中定义表单是可以的。
下面是新的控制器：
``
def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)
``:code

关联“default/display_form.html”视图：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

迄今，代码与之前的是相同的，但表单由语句 ``{{=form}}`` 生成，序列化 ``FORM`` 对象。

现在通过增加表单验证和处理，我们增加了一级复杂程度。
改变控制器如下：
``
def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request,session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)
``:code

关联“default/display_form.html”视图：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
<h2>Accepted variables</h2>
{{=BEAUTIFY(form.vars)}}
<h2>Errors in form</h2>
{{=BEAUTIFY(form.errors)}}
``:code

注意：
- 动作中，我们为输入字段“name”增加 ``requires=IS_NOT_EMPTY()`` 验证器。
- 动作中，我们增加对 ``form.accepts(..)``调用。
- 视图中，我们显示``form.vars``和``form.errors``，
以及表单和``request.vars``。

所有工作通过``form``对象方法``accepts`` 完成。它根据声明的要求（验证器表达）过滤``request.vars`` 。``accepts`` 方法存储那些通过验证的变量到 ``form.vars``。如果字段值不满
足要求，失败的验证器返回错误，错误存放在 ``form.errors``。 ``form.vars`` 和``form.errors``都是``gluon.storage.Storage``。
Storage对象与``request.vars``类似。前者包含通过验证的值，例如：
``
form.vars.name = "Max"
``:code

后者包含错误，例如：
``
form.errors.name = "Cannot be empty!"
``:code

 ``accepts`` 方法完整描述如下：
``onvalidation``:inxx
``
form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):
``:code

可选参数的意思在下一小节阐述。

第一个参数能是 ``request.vars`` 、 ``request.get_vars`` 、 ``request.post_vars`` 或简单 ``request``。后者等同与接受象输入的 ``request.post_vars``。

如果表单被接受， ``accepts`` 函数返回 ``True`` ，否者返回``False`` 。如果出错或当它没有提交（例如，第一时间它只是显示），表单不被接受。

下面是这个网页第一次显示看起来的样子：

[[image @///image/en5800.png center 300px]]

无效输入提交时它的样子：

[[image @///image/en5900.png center 300px]]

下图是合法输入提交的页面：

[[image @///image/en6000.png center 300px]]

#### ``process`` 和 ``validate``方法

下面语句的快捷方式：
``
form.accepts(request.post_vars,session,...)
``:code
是
``
form.process(...).accepted
``:code
后者不需要``request``和``session``参数（虽然你能选择指定它们）。
它与``accepts`` 不同，因为它自己返回表单。在内部，``process`` 调用accepts并传递参数给它。accepts返回的参数存储在 ``form.accepted``。

process函数采用一些 ``accepts`` 没有用的额外的参数：
- ``message_onsuccess``
- ``onsuccess``: 如果等于‘flash’（默认）并且表单被接受了，它会闪现上面的``message_onsuccess``
- ``message_onfailure``
- ``onfailure``: 如果等于‘flash’（默认）并且表单验证失败，它会闪现上面的 ``message_onsuccess``
- ``next`` 表单接受之后用户重定向
``onsuccess`` 和``onfailure`` 能做象 ``lambda form: do_something(form)``表单一样的函数

``
form.validate(...)
``:code

是下面的快捷形式

``
form.process(...,dbio=False).accepted
``:code

#### 隐藏字段Hidden fields

当上面的表单对象用 ``{{=form}}``序列化，因为之前``accepts`` 方法的调用，它现在看起来如下：
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input name="name" />
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

注意出现两个隐藏字段：“_formkey”和“_formname”。它们的出现是调用 ``accepts`` 触发的，它们起到两个不同但很重要的作用：
- 隐藏字段“_formkey”是一次性令牌，web2py用来阻止表单重复提交。当表单序列化并存在 ``session``中，这个字段值生成。当表单提交，这个值必须匹配
否则``accepts``返回``False``不报错，好像表单根本没有被提交。这是因为web2py不能决定表单是否被正确提交。
- 隐藏字段“_formname” web2py生成作为表单的名字，但名字可能被覆盖。这个字段是需要的，允许包含和处理多个表单的页。web2py用名字区别所提
交的表单。
- 可选隐藏字段指定为``FORM(..,hidden=dict(...))``。

The role of these hidden fields and their usage in custom forms and pages with multiple forms is discussed in more detail later in the chapter.

如果上面的表单用空的“name”字段提交，表单不能通过验证。当表单再次列化，它呈现如下：
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input value="" name="name" />
<div class="error">cannot be empty!</div>
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

注意在序列化的表单出现的“error”类DIV。web2py在表单中插入这个错误消息告知访问者不通过验证的字段。``accepts`` 方法就提交而言，决定表单提交，检查
“name”字段是否空，是否需要，最终从验证器插入错误消息到表单。

基本“layout.html”视图期望用来处理“error”类DIV。默认布局采用jQuery效果显示和向下滑动错误并用红色背景。查看11章获取更多详细信息。

#### ``keepvalues``参数

``keepvalues``:inxx

可选参数 ``keepvalues`` ，在表单被接受和没有重定向时，告诉web2py做什么，因此同一个表单再次被显示。默认，表单清空。如果``keepvalues``设置为``True``，表单用之前插入的值预处理。当你有表单设想用来重复插入多条相似的记录，这很有用。如果 ``dbio`` 参数设置为``False``，web2py接受表单后不执行任何DB插入/更改
操作。如果``hideerror``设置为``True``，表单又有错误，表单呈现时，这不会被显示（这取决于你从``form.errors`` 显示它们，不论怎样）。``onvalidation`` 参数下面介绍。

#### ``onvalidation``参数

 ``onvalidation`` 参数是 ``None`` 或是函数，函数用表单参数无返回值。这个函数验证后立即（如果验证通过），被调用并传递表单，在其它任何发生之前。这个函数的目的是多方面的。例如，它能对表单执行附加检查，最后给表单添加出错。它也能用来计算一些基于其它字段值的字段的值。它能用来，在记录创建/更改之前，触发一些动作（如发送电子邮件）。

下面是例子：
``
db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c < 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.process(onvalidation=my_form_processing).accepted:
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)
``:code

#### 检测记录修改

填写表单修改记录，很小可能性，另外一个用户同时编辑这一条记录。因此，当我们保存记录时，我们想检查可能的冲突。如下实现：

``
db.define_table('dog',Field('name'))

def edit_dog():
    dog = db.dog(request.args(0)) or redirect(URL('error'))
    form=SQLFORM(db.dog,dog)
    form.process(detect_record_change=True)
    if form.record_changed:
        # do something
    elif form.accepted:
        # do something else
    else:
        # do nothing
    return dict(form=form)
``:code

#### 表单和重定向

最通常使用表单的方法是通过自提交，因为所提交字段变量被生成表单同样的工作处理。一旦表单接受了，再次显示当前的页面是不寻常的（这里我们所做
的仅是保持简单）。更常见的是重定向访问者到“next”页面。

下面是新例子的控制器：
``
def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()
``:code

为在下一页面设置flash而不是当前页面，你必须使用``session.flash``而不是``response.flash``。重定向后，web2py把前者移到后者。注意使用``session.flash`` 需要
你不用 ``session.forget()``。

#### 多表单每页面

这节内容应用到``FORM``和 ``SQLFORM`` 对象。多表单每页面是是可能的，但你必须允许web2py 区分它们。如果这些通过 ``SQLFORM`` 从不同表得到，那么
web2py自动给它们不同的名字；否则你需要清晰地给它们不同的表单名字。下面是例子：
``
def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    if form1.process(formname='form_one').accepted:
        response.flash = 'form one accepted'
    if form2.process(formname='form_two').accepted:
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)
``:code

下面是它产生的输出：

[[image @///image/en6100.png center 300px]]

当访问者提交空form1，仅form1 显示错误；如果访问者提交空form2，仅form1显示错误消息。

#### 共享表单

这节内容应用到 ``FORM`` 和 ``SQLFORM`` 对象。这里讨论的是可能性不是推荐，因而用表单自提交总是好的实践。但，有时，你没有选择，因为发送表单的动作
和接收表单的动作属不同的应用。

能够生成表单提交给不同动作。这通过在``FORM`` 或 ``SQLFORM`` 对象属性中指定处理动作URL实现。例如：
``
form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.process(session=None, formname=None).accepted:
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()
``:code

注意因为“page_one”和“page_two”使用同样的 ``form``form，我们仅需定义一次，为了不重复我们自己，在所有动作之外替换它。控制器开头的公共部分代码每次
在给调用动作控制前被执行。

。因“page_one”不调用``process`` （不调用``accepts``）， 表单没有名字和键， 你必须在``process``传递 ``session=None`` 和设置``formname=None`` ，或者当“page_two”接收它，表单不验证。

### ``SQLFORM``

现在，通过用模型文件提供应用，我们来到下一阶段：
``
db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))
``:code

修改控制器如下：
``
def display_form():
   form = SQLFORM(db.person)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)
``:code

视图无需修改。

新控制器中，你无需构建 ``FORM``，因为 ``SQLFORM`` 构造函数从定义在模型中的表``db.person`` 创建了一个。这个新表单，序列化呈现如下：
``
<form enctype="multipart/form-data" action="" method="post">
  <table>
    <tr id="person_name__row">
       <td><label id="person_name__label"
                  for="person_name">Your name: </label></td>
       <td><input type="text" class="string"
                  name="name" value="" id="person_name" /></td>
       <td></td>
    </tr>
    <tr id="submit_record__row">
       <td></td>
       <td><input value="Submit" type="submit" /></td>
       <td></td>
    </tr>
  </table>
  <input value="9038845529" type="hidden" name="_formkey" />
  <input value="person" type="hidden" name="_formname" />
</form>
``:code

自动生成的表单比之前低级别表单要复杂得多。首先，它有若干行的表，每行有三列。第一列包含字段标签（从``db.person``决定的），第二列包含输入字段
（最终错误消息），和第三列是可选的，因此空（它能用``SQLFORM``构造函数中的字段填充）。

表单中的所有标签有从表和字段名继承的名字。这允许用CSS和JavaScript方便表单定制。这种能力在11章更详细讨论。

更重要的是，现在， ``accepts`` 方法为你做了更大量的工作。正如前面的例子，它执行输入验证，额外地，如果输入通过验证，它也执行数据库插入新的记录和
存储新记录唯一“id”在``form.vars.id`` 。

``SQLFORM`` 对象，通过存储上传文件到“upload”文件夹，也自动处理“upload”字段（在重新安全地命名之后以避免冲突，并防止目录遍历攻击），存储它们
的名字（它们的新名字）到数据库合适字段。在表单被处理后，新的文件名在``form.vars.fieldname`` （即在``request.vars.fieldname``里替换了  ``cgi.FieldStorage`` 对象）， 因而恰好上传后就可以容易地引用新名。

 ``SQLFORM`` 用复选框显示“boolean”值，文本框显示“text”值，值要在有限范围或下拉框，“upload”字段有允许用户下载已上传文件的链接。它隐藏了“blob”字段，因为它们设想是不同处理的，后面讨论。
例如，考虑下面的模型：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))
``:code

这种情况， ``SQLFORM(db.person)`` 生成如下所示的表单：

[[image @///image/en6200.png center 300px]]

``SQLFORM`` 构造函数允许各种定制，如仅显示字段子集，修改标签，添加值到可选第三列，或创建UPDATE和DELETE表单，相对于INSERT表单象当前这个。
``SQLFORM`` 是web2py里单个最大的节省时间的对象。

``SQLFORM``类定义在“gluon/sqlhtml.py”中。它能通过超越它的``xml``方法容易地扩展，方法序列化对象，修改它的输出。

``fields``:inxx ``labels``:inxx
``SQLFORM`` 构造函数的特征如下：
``
SQLFORM(table, record = None,
        deletable = False, linkto = None,
        upload = None, fields = None, labels = None,
        col3 = {}, submit_button = 'Submit',
        delete_label = 'Check to delete:',
        showid = True, readonly = False,
        comments = True, keepopts = [],
        ignore_rw = False, record_id = None,
        formstyle = 'table3cols',
	buttons = ['submit'], separator = ': ',
        **attributes)

``:code
- 可选第二参数为指定的记录（参看下一节），把INSERT表单转换为UPDATE表单。 ``showid``:inxx ``delete_label``:inxx ``id_label``:inxx ``submit_button``:inxx
- 如果 ``deletable`` 设置为 ``True``，UPDATE表单显示“Check to delete”复选框。这个字段的标签值通过``delete_label`` 参数设置。
- ``submit_button`` 设置提交按钮的值。
- ``id_label`` 设置记录“id”的标签。
-  如``showid`` 设置为``False``，记录“id”不显示。
- ``fields`` 是你想显示的可选字段名列表。如果列表提供，仅列表中的字段显示。
例如：
``
fields = ['name']
``:code
- ``labels`` 是字段标签字典。字典键是字段名，相应的值是作为标签显示的。如果
标签没有提高，web2py从字段名继承标签（它大写字段名，把下划线替换
为空格）。例如：
``
labels = {'name':'Your Full Name:'}
``:code
- ``col3`` 是第三列值的字典。例如：
``
col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}
``:code
- ``linkto`` 和``upload`` 对用户定义控制器可选URL ，允许表单处理引用字段。这在本章后详细讨论。
- ``readonly``。如果设置为True，只读显示表单
- ``comments``。如果设置为False，不显示col3评论
- ``ignore_rw``。
正常情况，create/update表单，标示writable=True的字段才显示，对只读表单，标示readable=True的字段才显示。设定 ``ignore_rw=True`` 导致哪
些限制被忽略，所有字段都显示。这大多数用在appadmin接口为每个表单显示所有字段，超过模型指示的。
-``formstyle``:inxx``formstyle``决定在html序列化表单所用的风格。
它可以是“table3cols”（默认），“table2cols”（一行为标签和评论，一行做输出），“ul”（生成无
序的输入字段列表），“divs”（表示使用css友好divs的表单，随意定制）。
``formstyle``也能是函数带（record_id,field_label,field_widget,filed_comment）属性参数，返回TR()对象。
- ``buttons``:inxx 是 ``INPUT``s 或 ``TAG.BUTTON``s （虽然技术上可以是任何帮助对象的组合）列表，添加到DIV，提交按钮所在。
- ``separator``:inxx ``separator`` 设置字符串区分表单标签和表单输入字段。
- 可选 ``attributes`` 是用下划线开头的参数，你想传递给``FORM`` tag 呈现 ``SQLFORM`` 对象。例如:
``
_action = '.'
_method = 'POST'
``:code

有一个特别``hidden``属性。当字典传递，它的项目翻译为“hidden”INPUT字段（参看第5章 ``FORM`` 帮助对象的例子）。

``
form = SQLFORM(....,hidden=...)
``:code
导致隐藏字段在提交时传递，不多不少。
``form.accepts(...)`` 不打算读取接收到的隐
藏字段并把它们移到form.vars。原因是考虑安全。隐藏字段可能被篡改。因此，你需要明确地把隐藏字段从请求移到表单：

``
form.vars.a = request.vars.a
form = SQLFORM(..., hidden=dict(a='b'))
``:code

#### ``SQLFORM`` 和 ``insert``/``update``/``delete``

表单接受时，``SQLFORM``创建一条新db记录。假设``form=SQLFORM(db.test)``:code，那么最后创建的记录的id能在``myform.vars.id``访问到。

``delete record``:inxx
如果你把记录作为可选第二参数传递到``SQLFORM`` 构造函数，表单成为该记录UPDATE表单。这意味着当表单提交，现有记录更新，没有新记录插入。如果你设
置参数``deletable=True``，UPDATE表单显示“check to delete”复选框。如果检查，记录被删除。


------
如果表单提交并且删除复选框选定，属性``form.deleted`` 设置为 ``True``。
------

你能修改之前例子的控制器，以便但我们传递附加整型参数到URL路径，如下：
``
/test/default/display_form/2
``:code

如果有相应id的记录， ``SQLFORM`` 为记录生成UPDATE/DELETE表单：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

第二行找到记录，第三行产生UPDATE/DELETE表单。第4行做所有相应的表单处理。

------
更新表单与创建表单非常相似，除了更新表单是用当前记录预填充的而且它预览图像。默认 ``deletable = True`` ，更新表单显示“delete record”选项。
------

Edit表单也包含隐藏INPUT字段``name="id"`` ，用来识别记录。这个id为了更多的安全考虑也存储在服务器侧，如果访问者篡改了这个字段的值，UPDATE不执行，
web2py产生语法错，“user is tampering with form”。

当字段用 ``writable=False``标示，字段不在创建表单中显示，在更新表单只读显示。
如果字段用``writable=False``和``readable=False``标示，那么字段根本不显示，即使是更新表单。

如下创建表单：
``
form = SQLFORM(...,ignore_rw=True)
``:code

忽略 ``readable`` 和``writable`` 属性，总是显示所有字段。``appadmin`` 中表单默认忽略它们。
如下创建表单：
``
form = SQLFORM(table,record_id,readonly=True)
``:code

总是只读模式显示所有字段，它们不能被接受。

#### HTML中的``SQLFORM`` 

有时，当你想用``SQLFORM``得益于它的生成和处理，但你需要在HTML中定制表单，你不能用``SQLFORM``对象参数获得，因此你不得不用HTML设计表单。
现在，编辑之前的控制器并添加新动作：
``
def display_manual_form():
   form = SQLFORM(db.person)
   if form.process(session=None, formname='test').accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill the form'
   # Note: no form instance is passed to the view
   return dict()
``:code

插入表单在相关联的“default/display_manual_form.html”视图：
``
{{extend 'layout.html'}}
<form>
<ul>
  <li>Your name is <input name="name" /></li>
</ul>
  <input type="submit" />
  <input type="hidden" name="_formname" value="test" />
</form>
``:code

注意动作不返回表单，因为它不需要传递到视图。视图包含在HTML中手动创建的表单。表单包含隐藏字段“_formname”，必须是同样``formname``，指定为动作中``accepts`` 的参数。Web2py用表单名，如果在同一页面有多个表单，决定那一个
是提交的。如果页面包含单个表单，你能设置``formname=None`` 并在视图中忽略隐藏字段。

``form.accepts`` 在``response.vars`` 中查找数据，与数据库表``db.person``字段匹配。这些字段子在HTML以格式``<input name="field_name_goes_here" />``:code 声明。

注意给定例子中，表单变量作为参数传递给URL。
如果不需要，``POST``协议必须指定。
更要注意，如果上传字段指定，表单需要设定允许。下面，展示两个选项：
``
<form enctype="multipart/form-data" method="post">
``:code

#### ``SQLFORM`` 和上传

“upload”字段类型是特殊的。它们以``type="file"``INPUT字段呈现。除非另有指定，上传文件用缓冲流式传送，用一个自动指定的安全名字存储在应用的“upload”
文件夹。这个文件的名字保存到上传类型的字段。

作为例子，考虑下面的模型：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))
``:code

你能用同样的控制动作“display_form”显示上例。

当你插入新的记录，表单允许你浏览文件。例如，选择jpg图像。如下，文件上传并存储：
``
applications/test/uploads/person.image.XXXXX.jpg
``:code

“XXXXXX”web2py为文件指定的随机标识符。

``content-disposition``:inxx

-------
注意，默认情况，上传文件源文件名b16编码，并为文件创建新文件名。这个名字通过默认“download”动作得到，用来设定到源文件名内容配置头。

-------

仅它的扩展保留。 只是安全性要求，因为文件名包含特殊字符可能允许访问者执行目录遍历攻击或其它恶意操作。

新文件名存储在``form.vars.image``。

当用UPDATE表单编辑记录，显示到现存上传文件的链接是很好的，web2py提供了方法实现。

如果你通过上传参数传递URL给``SQLFORM`` 构造函数，web2py用动作在那个URL下载文件。考虑下面的动作：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)
``:code

现在，在URL，插入新的记录：
``
http://127.0.0.1:8000/test/default/display_form
``:code

通过访问如下，上传图像，提交表单，编辑先创建的记录：
``
http://127.0.0.1:8000/test/default/display_form/3
``:code

（这里我们假定最后记录id=3）。表单将显示图像如下的预览：

[[image @///image/en6300.png center 300px]]

这个表单，当序列化，生成如下HTML：
``
<td><label id="person_image__label" for="person_image">Image: </label></td>
<td><div><input type="file" id="person_image" class="upload" name="image"
/>[<a href="/test/default/download/person.image.0246683463831.jpg">file</a>|
<input type="checkbox" name="image__delete" />delete]</div></td><td></td></tr>
<tr id="delete_record__row"><td><label id="delete_record__label" for="delete_record"
>Check to delete:</label></td><td><input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /></td>
``:code

包含允许下载上传文件的链接，复选框从数据库记录删除文件，如此存储NULL在“image”字段。

为什么这种机制显露？为什么你需要写下载函数？因为你想在下载函数中强化一些授权机制。看第9章的例子。
正常上传文件存储在“app/uploads”，但你能指定另外位置：
``
Field('image', 'upload', uploadfolder='...')
``
大多数操作系统，当许多文件在同一个文件夹，访问文件系统会变慢。如果你打算上传超过1000个文件，你能要求web2py在子文件夹中组织上传：
``
Field('image', 'upload', uploadseparate=True)
``


#### 存储源文件名

Web2py自动存储源文件名在新UUID文件名，当文件下载时取到它。就下载，源文件名存储在HTTP响应内容处置报头。它全部透明完成无需编程。偶尔，你想
把源文件名存储在数据库字段中。这种情况，你需要修改模型并增加字段来存储它：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))
``:code

然后你需要修改控制器处理它：
``
def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image!=None:
        form.vars.image_filename = request.vars.image.filename
    if form.process().accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

注意 ``SQLFORM`` 不显示“image_filename”字段。“display_form”动作把 ``request.vars.image``的文件名移到 ``form.vars.image_filename``，以便被accepts处理，
并存储在数据库。下载函数，在服务文件前，在数据库中检查源文件名，在内容处置头中使用它。

#### ``autodelete``属性（自动删除）
``autodelete``:inxx

 ``SQLFORM``，删除记录，不删除记录引用到的物理上传文件。原因是Web2py不知道该文件是否在用/链接其它表或用于其它目的。如果你知道党删除相应记录
时，删除文件是安全的，你可以如下操作：
``
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('file','upload',autodelete=True))
``:code

``autodelete`` 属性默认是 ``False`` 。当设置为 ``True`` ，当记录删除，确定文件也删除。

#### 链接到引用记录

现在，考虑两张表被引用字段链接的情况。例如：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', db.person),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db,db.person.id,'%(name)s')
``:code

一个人有几条狗，每条狗属于一个人，哪个是一个人。
狗主人要求用``'%(name)s'``引用合法``db.person.id`` by 。

让我们用这个应用的**appadmin** 接口添加一些人和他们的狗。

当编辑已有的人， **appadmin** UPDATE表单显示到页面的链接，列出属于这个人的狗。这个行动能用``SQLFORM``的参数``linkto`` 来复制。``linkto``指向从``SQLFORM`` 接收查询字符串新动作URL，并列出相应记录。下面是例子：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   url = URL('download')
   link = URL('list_records', args='db')
   form = SQLFORM(db.person, record, deletable=True,
                  upload=url, linkto=link)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

如下是页面：

[[image @///image/en6400.png center 300px]]

有一个叫做“dog.owner”的链接。这个链接的名字能通过``SQLFORM`` 的参数``labels`` 修改，例如：
``
labels = {'dog.owner':"This person's dogs"}
``:code

如果你点击链接指向到：
``
/test/default/list_records/dog?query=dog.owner%3D5
``:code

“list_records”是指定的动作，用``request.args(0)`` 设置引用表名字以及用 ``request.vars.query`` 设置SQL查询字符串。
URL中的查询字符串包含值“dog.owner=5”，适当的url编码（当URL解析时，web2py自动解码）。
你能轻易地实现很一般的“list_records”动作如下：
``
def list_records():
    table = request.args(0)
    query = request.vars.query
    records = db(query).select(db[table].ALL)
    return dict(records=records)
``:code

用关联“"default/list_records.html”视图：
``
{{extend 'layout.html'}}
{{=records}}
``:code

当查询返回一组记录并序列化在视图中，一开始，它转化为SQLTABLE对象（不与Table一样），然后序列化到HTML表，此处每个字段相对应表的一列。

#### 预填充表单
使用下面语法总能预填充表单：
``
form.vars.name = 'fieldvalue'
``:code

如上语句必须在表单声明后和在表单被接受前插入，无论字段（例子中的“name”）是否在表单中显式可见。

#### 添加额外表单元素到``SQLFORM``
有时，你希望在创建后添加额外的项目到你的表单。例如，你可能希望添加复选框用来确认用户同意你网站的条款和条件：
``
form = SQLFORM(db.yourtable)
my_extra_element = TR(LABEL('I agree to the terms and conditions'), \
                      INPUT(_name='agree',value=True,_type='checkbox'))
form[0].insert(-1,my_extra_element)
``:code

变量 ``my_extra_element``要与表风格适应。这个例子， 假定了， 默认 ``formstyle='table3cols'`` 。

提交后， ``form.vars.agree`` 包含复选框的状态，例如，这可以用在 ``onvalidation`` 动作。

#### 无数据库IO的``SQLFORM`` 

有时，当你想用``SQLFORM``从数据库表生成表单时，你也相应地想验证提交表单，但你不想任何数据库中自动的NSERT/UPDATE/DELETE命令。例如，下面
是一个例子，当一个字段的值要从其它输入字段的值计算。当你需要对输入数据执行附加验证，不能通过标准验证器时，也是一种情况。
很轻松地把下面分解：
``
form = SQLFORM(db.person)
if form.process().accepted:
    response.flash = 'record inserted'
``:code

成：
``
form = SQLFORM(db.person)
if form.validate():
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'
``:code

同样为UPDATE/DELETE表单，可把如下分解：
``
form = SQLFORM(db.person,record)
if form.process().accepted:
    response.flash = 'record updated'
``:code

成：
``
form = SQLFORM(db.person,record)
if form.validate():
    if form.deleted:
        db(db.person.id==record.id).delete()
    else:
        record.update_record(**dict(form.vars))
    response.flash = 'record updated'
``:code

在表包括“upload”类型字段（“"fieldname”），``process(dbio=False)`` 和 ``validate()`` 处理上传文件储存，似乎``process(dbio=True)``，默认行为。

Web2py对上传文件指定的名字在其中找到：
``
form.vars.fieldname
``:code

### ``SQLFORM.factory``

有些情况当你想生成表单，你有数据库表但你不想用数据库表。你简单地想利用 ``SQLFORM`` 能力生成CSS友好的漂亮的表单，并可能执行文件上传和重命名。
这能通过``form_factory``完成。下面是例子，你生成表单，执行验证，上传一个文件，在 ``session`` 存储所有东西：
``
def form_from_factory():
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.process().accepted:
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.filename = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

下面是“default/form_from_factory.html”视图：
``
{{extend 'layout.html'}}
{{=form}}
``:code

你需要下划线而不是空格做字段标签，或显式传递``labels``字典到``form_factory``, 就像你为``SQLFORM``要做的。默认``SQLFORM.factory`` 用所生成的html“id” 属
性生成表单，好像表单从叫做"“no_table”的表生成。要改变这个虚拟表名，用给制造厂的``table_name`` 属性
``
form = SQLFORM.factory(...,table_name='other_dummy_name')
``:code

如果你要放置两个制造厂生成的表单在同一张而避免CSS冲突，修改 ``table_name`` 是必须的。

#### 单个表单多表

经常出现你有两个表（例如‘client’和‘address’ ），引用链接在一起， 你想创建单个表单允许掺入关于client和它的默认地址信息。下面是如何实现：模型：

model:
``
db.define_table('client',
     Field('name'))
db.define_table('address',
    Field('client',db.client,writable=False,readable=False),
    Field('street'),Field('city'))
``:code

控制器：
``
def register():
    form=SQLFORM.factory(db.client,db.address)
    if form.process().accepted:
        id = db.client.insert(**db.client._filter_fields(form.vars))
        form.vars.client=id
        id = db.address.insert(**db.address._filter_fields(form.vars))
        response.flash='Thanks for filling the form'
    return dict(form=form)
``:code

注意SQLFORM.factory（它从表的公用字段产生one表单，也继承它们的校验
器）。表单接受这个执行两次插入，一些数据在一张表而一些在另一张表。

-------
这仅当表没有相同的字段名。
-------

### CRUD
``CRUD``:inxx ``crud.create``:inxx ``crud.update``:inxx ``crud.select``:inxx ``crud.search``:inxx ``crud.tables``:inxx ``crud.delete``:inxx

最近添加到web2py的是Create/Read/Update/Delete (CRUD) API，在SQLFORM上面。CRUD创建SQLFORM，但它简化了编码，应为它包含了表单创建、表单
处理、警告和重定向，所有功能到一个函数。

第一件要注意的事，CRUD区别于目前我们用到的其它web2py API，因为它没有披露。它必须导入。也必须链接到指定数据库。例如：
``
from gluon.tools import Crud
crud = Crud(db)
``:code

定义在上面的``crud``对象提供下列API：

``crud.tables``:inxx ``crud.create``:inxx ``crud.read``:inxx ``crud.update``:inxx ``crud.delete``:inxx ``crud.select``:inxx .
- ``crud.tables()`` 返回在数据库定义的表的列表。
- ``crud.create(db.tablename)`` 返回给表tablename的创建表单。
- ``crud.read(db.tablename, id)`` 返回给tablename和记录id的只读表单。
- ``crud.update(db.tablename, id)``返回给tablename和记录id的更新表单。
- ``crud.delete(db.tablename, id)`` 删除记录。
- ``crud.select(db.tablename, query)`` 返回从表查询到的记录列表。
- ``crud.search(db.tablename)`` 返回元组（表单，记录），表单是搜索表单，记录是基于提交的搜索表单的记录列表。
- ``crud()`` 返回基于``request.args()``其中之一。

例如，下面动作：
``
def data(): return dict(form=crud())
``:code

将显露下面的URL：
``
http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]
``:code

而，下面的动作：

``
def create_tablename():
    return dict(form=crud.create(db.tablename))
``:code

会展露创建方法：

``
http://.../[app]/[controller]/create_tablename
``:code

而下面的动作：

``
def update_tablename():
    return dict(form=crud.update(db.tablename, request.args(0)))
``:code

只展示update方法

``
http://.../[app]/[controller]/update_tablename/[id]
``:code

等等。

CRUD的行为能用两种方法定制：设定``crud`` 对象的一些属性或者传递额外参数到各自方法。

#### 设置

下面是当前CRUD属性的完整列表、它们的默认值和意思：
对所有crud表单强制认证：

``
crud.settings.auth = auth
``:code
用法在第9章讲解。
指定控制器，定义返回 ``crud``对象的``data`` 函数：

``
crud.settings.controller = 'default'
``:code

指定URL，成功“create”记录后重定向：

``
crud.settings.create_next = URL('index')
``:code

指定URL，成功“update”记录后重定向：

``
crud.settings.update_next = URL('index')
``:code

指定URL，成功“delete”记录后重定向：

``
crud.settings.delete_next = URL('index')
``:code

指定URL用来链接上传文件：

``
crud.settings.download_url = URL('download')
``:code

为 ``crud.create`` 表单，指定额外函数在标准校验过程完成后执行：

``
crud.settings.create_onvalidation = StorageList()
``:code

``StorageList`` 作为 ``Storage`` 对象是相同的，它们定义在文件“gluon/storage.py”，但默认 ``[]`` 相对于 ``None``。它允许下面的语法：

``
crud.settings.create_onvalidation.mytablename.append(lambda form:....)
``:code

为 ``crud.update``表单，指定额外函数在标准校验过程完成后执行：

``
crud.settings.update_onvalidation = StorageList()
``:code

``crud.create``表单完成后，指定额外函数执行：

``
crud.settings.create_onaccept = StorageList()
``:code

``crud.update``表单完成后，指定额外函数执行：

``
crud.settings.update_onaccept = StorageList()
``:code

``crud.update`` 表单完成后，如果记录删除，指定额外函数执行：

``
crud.settings.update_ondelete = StorageList()
``:code

 ``crud.delete``表单完成后，指定额外函数执行：

``
crud.settings.delete_onaccept = StorageList()
``:code

要决定“update”表单是否有“delete”按钮：

``
crud.settings.update_deletable = True
``:code

要决定“update”表单是否显示已编辑记录的id：

``
crud.settings.showid = False
``:code

要决定，表单成功提交之后，是否保存之前插入值或重置到默认：

``
crud.settings.keepvalues = False
``:code

Crud总是检测正在编辑的记录，介于表单显示和提交的时间区间，是否被第三方修改，这个动作等同于：
``
form.process(detect_record_change=True)``

它在如下设置：

``
crud.settings.detect_record_change = True
``:code
它能通过设置变量为``False``改变/禁用。

你能用下面语句改变表单风格

``
crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'
``:code

你能在所有crud表单中设置分隔符：

``
crud.settings.label_separator = ':'
``:code

你能用下面语句给表单添加验证码，用同样规矩身份认证：

``
crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None
``:code


#### 消息

下面是定制消息列表：
``
crud.messages.submit_button = 'Submit'
``:code

为create和update表单设定“submit”按钮文本。
``
crud.messages.delete_label = 'Check to delete:'
``:code

在“update”表单中设定“delete”按钮标签。
``
crud.messages.record_created = 'Record Created'
``:code

就成功记录创建设定flash消息。
``
crud.messages.record_updated = 'Record Updated'
``:code

就成功记录更新设定flash消息。
``
crud.messages.record_deleted = 'Record Deleted'
``:code

就成功记录删除设定flash消息。
``
crud.messages.update_log = 'Record %(id)s updated'
``:code

就成功记录更新设定日志消息。
``
crud.messages.create_log = 'Record %(id)s created'
``:code

就成功记录创建设定日志消息。
``
crud.messages.read_log = 'Record %(id)s read'
``:code

就成功记录访问设定日志消息。
``
crud.messages.delete_log = 'Record %(id)s deleted'
``:code

就成功记录删除设定日志消息。

注意``crud.messages`` 属于类 ``gluon.storage.Message`` ，它与 ``gluon.storage.Storage``很像，但它自动地翻译它的值无需``T``运算符。

日志消息当且仅当CRUD连接到Auth（认证）使用，第9章讨论。事件日志记录
在Auth表“auth_events”。

#### 方法

CRUD方法行为，每次调用基础上，也能定制。
下面是它们的详尽描述：
``
crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero, showall, chkall)
``:code
- ``table`` 是方法要作用于的DAL表或表名。
- ``record``和 ``record_id`` 是方法要作用于的记录的id。
- ``next`` 是成功后重定向的URL。如果URL包含子串“[id]”，当前创建/更新记录的id会被替换。
- ``onvalidation`` 有同SQLFORM(..., onvalidation)一样的功能。
- ``onaccept`` 是表单提交接受后并作用于调用的函数，但在重定向以前。
- ``log`` 是日志消息。CRUD内的日志消息是 ``form.vars`` 字典中形如“%(id)s”的变量。
- ``message`` 表单接受的flash消息。
- 当记录通过"update" 表单删除，``ondelete``代替``onaccept`` 被调用。
- ``deletable`` 决定“update”表单是否该有删除选项。
- ``query`` 是用来查询记录的查询命令。
- ``fields`` 是查询字段的列表。
- ``orderby`` 决定被查询记录排序（参看第6章）。
- ``limitby`` 决定查询记录要显示的范围（参看第6章）。
- ``headers`` 是表头名字的字典。
- ``queries`` 列表，象 ``['equals', 'not equal', 'contains']`` 包含搜索表单中允许的方法
- ``query_labels`` 字典象``query_labels=dict(equals='Equals')`` 给搜索方法名字。
- ``fields`` 在搜索widget中列出的字段列表。
- ``field_labels`` 字典，把字段名映射到标签。
- ``zero`` 默认“choose one”用作默认选项在搜索widget下拉。
- ``showall`` 设定为True如果你想第一次调用每次查询rows被返回（1.98.2版后添加）。
- ``chkall`` 设定为True打开搜索表单中所有复选框（1.98.2版后添加）。

下面是单个控制器函数的用法例子：
``
## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
           message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
           headers={'person.name': 'Name'})
    return dict(form=form, persons=persons)
``:code

下面是一个非常通用的控制函数，让你搜索、创建和编辑从表名传递自request.args(0)的任意表的任何记录：
``
def manage():
    table=db[request.args(0)]
    form = crud.update(table,request.args(1))
    table.id.represent = lambda id, row: \
       A('edit:',id,_href=URL(args=(request.args(0),id)))
    search, rows = crud.search(table)
    return dict(form=form,search=search,rows=rows)
``:code

注意``table.id.represent=...`` 行告诉web2py改变id字段标识，显示链接而不是页面本身，以request.args(1)传递 id，它把创建页转换为更新页。

#### 记录版本

SQLFORM 和 CRUD提供给数据库记录定版本：

如果你有表（db.mytable）需要全部版本历史，你只需做如下：
``
form = SQLFORM(db.mytable, myrecord).process(onsuccess=auth.archive)
``:code

``
form = crud.update(db.mytable, myrecord, onaccept=auth.archive)
``:code

就更新时，``auth.archive``定义新表叫做**db.mytable_archive**（名字从它引用到的表继承）它存储记录的备份（如同它更新前）在创建文件夹表，包含对当前记录
的引用。
因为记录实际更新（只有它之前的状态存档），引用不会损坏。
所有都在后台完成。如果你希望访问存档的表，你需要在模型中定义它：
``
db.define_table('mytable_archive',
   Field('current_record',db.mytable),
   db.mytable)
``:code

注意表扩展``db.mytable`` （包括它的所有字段），并添加到``current_record``当前记录
的引用。

``auth.archive`` 不对存储记录时间戳，除非你的源表有时间戳字段，例如：

``
db.define_table('mytable',
    Field('created_on', 'datetime',
          default=request.now, update=request.now, writable=False),
    Field('created_by', db.auth_user,
          default=auth.user_id, update=auth.user_id, writable=False),
``:code

这些字段没什么提别的，你可以给它们任何你想叫的名字。记录存档之前，它们被填充，并用记录的每个拷贝存档。文档属性表的名字或参考字段名能象如
下修改：

``
db.define_table('myhistory',
    Field('parent_record',db.mytable),
    db.mytable)
## ...
form = SQLFORM(db.mytable,myrecord)
form.process(onsuccess = lambda form:auth.archive(form,
             archive_table=db.myhistory,
             current_record='parent_record'))
``:code

### 定制表单Custom forms

如果表单用SQLFORM, SQLFORM.factory或CRUD创建，有多个办法把它嵌入视图允许多种程度定制。思考下面模型例子：
``
db.define_table('image',
    Field('name'),
    Field('file', 'upload'))
``:code

和上传动作
``
def upload_image():
    return dict(form=crud.create(db.image))
``:code

为 ``upload_image``嵌入表单到视图最简单的方法是
``
{{=form}}
``:code

这个结果是标准的表布局。如果你想用不同的布局，你能分解表单为组件
``
{{=form.custom.begin}}
Image name: <div>{{=form.custom.widget.name}}</div>
Image file: <div>{{=form.custom.widget.file}}</div>
Click here to upload: {{=form.custom.submit}}
{{=form.custom.end}}
``:code

对字段``form.custom.widget[fieldname]`` 序列化到合适的widget。如果表单提交，它包含错误，它们也一样追加在下面的widget。
上面的例子表单显示为下面的图像。

[[image @///image/en6500.png center 300px]]

注意相似的结果可用下面的方法得到：

``
crud.settings.formstyle='table2cols'
``:code

无需使用定制表单。其它可能的``formstyle``s 是“table3col”（默认）、“divs”和“ul”。

如果你不想用web2py序列化的widget，你能用HTML替换它们。有些变量可用来完成这个：
- ``form.custom.label[fieldname]``包含给字段的标签。
- ``form.custom.comment[fieldname]`` 包含给字段的评论。
- ``form.custom.dspval[fieldname]`` 表单类型和字段类型相关显示字段的表示。
- ``form.custom.inpval[fieldname]`` 表单类型和字段类型相关值用在字段编码。遵循下面规定是重要的。


#### CSS规定 CSS conventions

由SQLFORM, SQLFORM.factory或CRUD生成的表单中的标签，遵循严格的CSS命名习惯，可以用来更深入地定制表单。
给定表“mytable”，和“string”类型字段“myfield”，默认被下面语句呈现
``
SQLFORM.widgets.string.widget
``:code

看起来象下面这样：
``
<input type="text" name="myfield" id="mytable_myfield"
       class="string" />
``:code

注意：
- INPUT标签类与字段类型是一样的。这对jQuery代码在“web2py_ajax.html”中工作是非常重要的。要确保你只能有数字在“integer”和“double”字段，
“time”、“date”和“datetime”字段显示弹出日历/日期拾取calendar/datepicker。
- id是类的名字加上字段名，用下划线连接。这允许你唯一地引用到字段，通过，例如``jQuery('#mytable_myfield')`` ，操作字段的stylesheet或绑定关联字段
事件的动作（focus, blur, keyup等）。
- name是，正如你想的，字段名。

#### 隐藏错误 Hide errors
``hideerror``:inxx

偶尔，你想在除了默认的一些地方禁用自动错误放置和显示表单错误消息。这能简单地被实现：

- FORM或SQLFORM的情况，传递``hideerror=True`` 给``accepts`` 方法。
- CRUD的情况，设置``crud.settings.hideerror=True``。

你也想修改视图来显示错误（因为它们不再自动显示）。
下面是例子，错误显示在表单上面而不在表单里。
``
{{if form.errors:}}
  Your submitted form contains the following errors:
  <ul>
  {{for fieldname in form.errors:}}
    <li>{{=fieldname}} error: {{=form.errors[fieldname]}}</li>
  {{pass}}
  </ul>
  {{form.errors.clear()}}
{{pass}}
{{=form}}
``:code

错误会象下面图像展示的那样显示：

[[image @///image/en6600.png center 300px]]

这个机制适用于定制表单。


### 验证器
``validators``:inxx

验证器是用来验证输入字段（包括从数据库表生成的表单）的类。
下面是用验证器验证``FORM``例子：
``
INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))
``:code

下面是按表字段如何要求验证器：
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()
``:code

总是用字段``requires`` 属性指定验证器。字段有单个或多个验证器。多验证器由列表：
``
db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]
``:code

通常验证器由函数``accepts``自动调用``FORM``的 ``process`` 或其它包含表单的HTML帮助对象。它们以列表中的顺序依次调用。
也可以对字段显式调用验证器。

``
db.person.name.validate(value)
``

返回元组 ``(value,error)`` ，如果值通过验证 ``error`` 是 ``None`` 。

内建的验证器有构造函数带一个可选参数：

``
IS_NOT_EMPTY(error_message='cannot be empty')
``:code

对任何验证器，``error_message`` 允许你超越默认错误消息。

下面是数据表验证器的例子：
``
db.person.name.requires = IS_NOT_EMPTY(error_message='fill this!')
``:code

我们用翻译运算符 ``T`` 允许全局化。注意默认错误消息不翻译。

注意能用``list:`` 的验证器，字段类型是：

- ``IS_IN_DB(...,multiple=True)``
- ``IS_IN_SET(...,multiple=True)``
- ``IS_NOT_EMPTY()``
- ``IS_LIST_OF(...)``

后者能用来，应用任何的验证器到列表中的每个项。

#### 验证器

##### ``IS_ALPHANUMERIC``
``IS_ALPHANUMERIC``:inxx

这个验证器检查字段值仅包含字符a-z、A-Z或 0-9。
``
requires = IS_ALPHANUMERIC(error_message='must be alphanumeric!')
``:code

##### ``IS_DATE``
``IS_DATE``:inxx

这个验证器检查字段值包含指定格式的合法日期。用翻译运算符指定格式是好的实践，以便不同的地方支持不同的格式。
``
requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message='must be YYYY-MM-DD!')
``:code

有关%的完全描述，直接看IS_DATETIME验证器。

##### ``IS_DATE_IN_RANGE``
``IS_DATE_IN_RANGE``:inxx

作用与之前的验证器非常象，但允许指定范围：
``
requires = IS_DATE_IN_RANGE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008,1,1),
                   maximum=datetime.date(2009,12,31),
                   error_message='must be YYYY-MM-DD!')
``:code

有关%的完全描述，直接看IS_DATETIME验证器。

##### ``IS_DATETIME``
``IS_DATETIME``:inxx

这个验证器检查字段值包含合法的指定格式的日期时间。用翻译运算符指定格式是好的实践，以便不同的地方支持不同的格式。
``
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message='must be YYYY-MM-DD HH:MM:SS!')
``:code

下列符号能用作格式字符串（下面显示符号和例子字符串）：
``
%Y  '1963'
%y  '63'
%d  '28'
%m  '08'
%b  'Aug'
%b  'August'
%H  '14'
%I  '02'
%p  'PM'
%M  '30'
%S  '59'
``:code

##### ``IS_DATETIME_IN_RANGE``
``IS_DATETIME_IN_RANGE``:inxx

作用与之前的验证器非常象，但允许指定范围：
``
requires = IS_DATETIME_IN_RANGE(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008,1,1,10,30),
                       maximum=datetime.datetime(2009,12,31,11,45),
                       error_message='must be YYYY-MM-DD HH:MM::SS!')
``:code

有关%的完全描述，直接看IS_DATETIME验证器。

##### ``IS_DECIMAL_IN_RANGE``
``IS_DECIMAL_IN_RANGE``:inxx

``
INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10, dot="."))
``:code

它把输入转化为Python十进制，如果十进制数不在指定范围内生成错误。与Python Decimal算术做了比较。
最小和最大限制可以是None，意味着没有下或上界。``dot``参数可选，允许你全局化用来分隔十进制数。



##### ``IS_EMAIL``
``IS_EMAIL``:inxx

它检查看起来象电子邮件地址的字段值。它不尝试发送邮件证实。
``
requires = IS_EMAIL(error_message='invalid email!')
``:code

##### ``IS_EQUAL_TO``
``IS_EQUEL_TO``:inxx

检查验证的值是否等于给定值（可能是变量）：
``
requires = IS_EQUAL_TO(request.vars.password,
                       error_message='passwords do not match')
``:code

##### ``IS_EXPR``
``IS_EXPR``:inxx

它的第一个参数是字符串包含逻辑表达式也就是一个变量值。如果表达式的值为``True``，它验证字段值。例如：
``
requires = IS_EXPR('int(value)%3==0',
                   error_message='not divisible by 3')
``:code

应首先检查值是否是整型，以防异常发生。
``
requires = [IS_INT_IN_RANGE(0, 100), IS_EXPR('value%3==0')]
``:code

##### ``IS_FLOAT_IN_RANGE``
``IS_FLOAT_IN_RANGE``:inxx

检查字段值是否有限范围内的浮点数，下面的例子 ``0 <= value <= 100`` 
``
requires = IS_FLOAT_IN_RANGE(0, 100, dot=".",
         error_message='too small or too large!')
``:code

``dot`` 参数可选，允许你全局化用来分隔十进制数。

##### ``IS_INT_IN_RANGE``
``IS_INT_IN_RANGE``:inxx

检查字段值是否有限范围整型数，下面
 ``0 <= value < 100`` 例子：

``
requires = IS_INT_IN_RANGE(0, 100,
         error_message='too small or too large!')
``:code

##### ``IS_IN_SET``
``IS_IN_SET``:inxx
``multiple``:inxx

检查字段值是否在集合内：
``
requires = IS_IN_SET(['a', 'b', 'c'],zero=T('choose one'),
         error_message='must be a or b or c')
``:code

零个参数是可选的，它决定默认文本选项，这个选项不会被``IS_IN_SET``验证器自己接受。如果你不想“”选项，设置  ``zero=None``。

 ``zero``选项在修改版中介绍引入（1.67.1）。它不破快后向兼容，这个意义上它不影响应用，但之后它不改变它们的行为，之前没有``zero``选项。

集合的元素必须总是字符串，除了这个验证器以 ``IS_INT_IN_RANGE`` 开始（值转换为整型）或 ``IS_FLOAT_IN_RANGE`` （值转换为浮点型）。例如：
``
requires = [IS_INT_IN_RANGE(0, 8), IS_IN_SET([2, 3, 5, 7],
          error_message='must be prime and less than 10')]
``:code

你也能用字典或元组列表是下拉列表更有描述：
``
#### Dictionary example:
requires = IS_IN_SET({'A':'Apple','B':'Banana','C':'Cherry'},zero=None)
#### List of tuples example:
requires = IS_IN_SET([('A','Apple'),('B','Banana'),('C','Cherry')])
``:code


##### ``IS_IN_SET``和 Tagging

``IS_IN_SET`` 验证器有可选属性 ``multiple=False``。如果设置为True，多个值可存在一个字段中。字段类型必须是``list:integer`` 或 ``list:string``。 创建和更新表单的``multiple`` 应用是自动处理的，但对DAL时透明的。我们强烈建议用jQuery multiselect插件呈现多字段。

------
注意 ``multiple=True``， ``IS_IN_SET``会接受``zero`` o或更多值，即当没有任何选择，它接受字段。 ``multiple`` 也能是表单 ``(a,b)`` 元组， ``a``和 ``b`` 是分别是能被查询的最小和（互斥）最大项目数
------

##### ``IS_LENGTH``
``IS_LENGTH``:inxx

检查字段值长度满足给定边界。适用于文本和文件输入。
它的参数是：
- maxsize: 最大允许长度/大小（默认255）
- minsize: 最小允许长度/大小

例如：检查文本字符串是否少于33个字符：
``
INPUT(_type='text', _name='name', requires=IS_LENGTH(32))
``:code

检查密码字符串是否不超过5个字符：
``
INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))
``:code

检查上传文件大小在1KB和1MB之间：
``
INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))
``:code

除了文件之外，对所有字段类型，它检查值的长度。文件条件，值是 ``cookie.FieldStorage``，因此它验证文件数据的长度，这是直觉想到的举动。

##### ``IS_LIST_OF``
``IS_LIST_OF``:inxx

这不是合适的验证器。它用来允许字段验证返回多个值。它用在那些罕见的情况当表单包含多个同名字段或多个选择框（复选框）。它仅有的参数是另一个验
证器，它所做的是应用其它验证器到列表中的每个元素。例如，下面的表达式检查列表中的每个项是否0-10范围的整数：
``
requires = IS_LIST_OF(IS_INT_IN_RANGE(0, 10))
``:code

它从不返回错误，不包含错误消息。内部验证器控制错误生成。

##### ``IS_LOWER``
``IS_LOWER``:inxx

这个验证器从不返回错误。它就就把值转换为小写。
``
requires = IS_LOWER()
``:code

##### ``IS_MATCH``
``IS_MATCH``:inxx

这个验证器用来匹配值与正则表达式，如果不匹配返回错误。下面是验证US邮政编码用法的例子：
``
requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')
``:code

下面是验证IPv4地址的例子（注意：IS_IPV4验证器更适合这个目的）：
``
requires = IS_MATCH('^\d{1,3}(\.\d{1,3}){3}$',
         error_message='not an IP address')
``:code

下面是验证US电话号码的用法例子：
``
requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')
``:code

有关Python正则表达式更多信息，参考Python官方文档。
``IS_MATCH`` 用可选参数 ``strict`` 默认``False``。当设置为 ``True`` ，它只匹配字段串开头：

``
>>> IS_MATCH('a')('ba')
('ba', <lazyT 'invalid expression'>) # no pass
>>> IS_MATCH('a',strict=False)('ab')
('a', None)                          # pass!
``

``IS_MATCH`` 用另一个可选参数``search`` 默认 ``False``。当设置为``True``，它用regex方法 ``search`` 而不是 ``match`` 方法验证字符串。

##### ``IS_NOT_EMPTY``
``IS_NOT_EMPTY``:inxx

这个验证器检查字段值的内容不是空字符串。
``
requires = IS_NOT_EMPTY(error_message='cannot be empty!')
``:code

##### ``IS_TIME``
``IS_TIME``:inxx

这个验证器检查字段值是否包含指定格式的合法时间。
``
requires = IS_TIME(error_message='must be HH:MM:SS!')
``:code

##### ``IS_URL``
``IS_URL``:inxx

如果以下任何为true，拒绝URL字符串：
- 字符串为空或None
- 字符串使用了在URL中不允许的字符
- 字符串破坏了任何HTTP语法规则
- 方案指定的URL（如果指定了）不是‘http’或‘https’
- 顶级域名（如果主机名字指定了）不存在

（这些规则基于``RFC2616``:cite）

这个函数仅检查URL的语法。例如，它不检查URL指向真实的文档， 亦或它仅为语法上。在简写的URL的情况（例如，‘google.ca’），这个函数自动在URL
前添加‘http://’。
如果用到参数mode=’generic’，那这个函数功能的行为改变了。如果下面任何为真，它拒绝URL字符串：
- 字符串为空或None
- 字符串使用了在URL中不允许的字符
- 方案指定的URL（如果指定了）不是合法的

（这些规则基于``RFC2396``:cite ）

允许的方案列表用许可的allowed_schemes参数定制。如果你从列表剔除了None，则缩写URL（缺少方案比如‘http’）被拒绝。

默认预先添加方案用prepend_scheme定制。如果你设置prepend_scheme为None，那么添加方案无效。URL要求预添加的解析仍被接受，但它的返回值不会被修
改。

IS_URL兼容``RFC3490``:cite 国际域名命名（IDN）标准。因此，URL可以是常规字符串或unicode字符串。如果URL域名组成部分（比如，google.ca）包含非USASCII
字母，那域名会转换成Punycode（``RFC3492``:cite )。IS_URL有点点超越了标准，允许非US-ASCII字符在路径出现以及URL组成的查询。这些非USASCII
字符将采用编码。例如，空格编码为‘%20’ 。unicode字符用十六进制码0x4e86会编成‘% 4e%86’。
例如：
``
requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'],
                  prepend_scheme='https')
``:code

##### ``IS_SLUG``
``IS_SLUG``:inxx
``
requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')
``:code

如果``check``设置为``True``，它检查验证的值是否是slug（只允许字母数字字符和不重复破折号）。

如果``check``设置为 ``False`` （默认），它把输入值转换为slug。

##### ``IS_STRONG``
``IS_STRONG``:inxx

强制字段复杂性要求（通常口令密码字段）
例如：
``
requires = IS_STRONG(min=10, special=2, upper=2)
``:code

这里
- min是值的最小长度
- special是要求的特殊符号的最小个数，特殊符号是下列中的任何一个``!@#$%^&*(){}[]-+``
- upper是大写字母的最小个数

##### ``IS_IMAGE``
``IS_IMAGE``:inxx

这个验证器检查通过文件输入上传的文件是否用所选图像格式中的一保存种，有给定限制范围的尺寸（宽和高）。
它不检查文件最大尺寸（用IS_LENGTH实现）。如果没有数据上传，它返回验证失败。它支持文件格式BMP、GIF、JPEG、PNG，它不要求Python图像库。
代码部分取自参看文献``source1``:cite

它用下面参数：
- extensions: 迭代器包含的允许图像文件小写扩展
- maxsize: 迭代器包含图像的最大宽度和高度
- minsize: 迭代器包含图像的最小宽度和高度

用（-1，-1）为最小尺寸旁路图像尺寸检查。
下面是一些例子：
- 检查上传文件是否是支持的图像格式：
``
requires = IS_IMAGE()
``:code
- 检查上传文件是JPEG或PNG
``
requires = IS_IMAGE(extensions=('jpeg', 'png'))
``:code

- 检查上传文件是否PNG最大尺寸200*200像素：
``
requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))
``:code

- 注意：就给包含 ``requires = IS_IMAGE()``表显示编辑表单， ``delete`` 复选框不出现，因为删除文件将导致验证失败。要显示``delete`` 复选框用下面的验证：
``
requires = IS_EMPTY_OR(IS_IMAGE())
``:code


##### ``IS_UPLOAD_FILENAME``
``IS_UPLOAD_FILENAME``:inxx

该验证器检查通过文件输入上传的文件名和扩展名是否符合给定标准。
它根本不保证文件类型。如果没有数据上传，返回验证失败。
它的参数是：
- filename: 文件名（.前）正则表达式
- extension: 扩展名（.后）正则表达式
- lastdot: 点用做文件名/扩展名的分隔符。``True``指明最后的点（例如，“file.tar.gz”分解为“file.tar”+“gz”），如果``False``则表明第一个点（“file.tar.gz”分解为
“file”+“tar. gz”）
- case: 0意思保持不变；1意思把字符串转换为小写（默认）；2意味把字符串转换为大写。

如果没有点存在，扩展名检查将针对空字符串开展，文件名检查将针对整个字
符串值。
例如：
检查文件是否有pdf扩展名（不区分大小写）：
``
requires = IS_UPLOAD_FILENAME(extension='pdf')
``:code

检查文件是否有扩展名tar.gz，文件名用backup开头：
``
requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)
``:code

检查文件是否没有扩展名并且名字不匹配README（区分大小写）：
``
requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)
``:code

##### ``IS_IPV4``
``IS_IPV4``:inxx

该验证器检查字段值是否是十进制形式IPv4地址。可以设置强制地址在一定范围。
IPv4正则表达式来自参考文献[.``regexlib``:cite。
它的参数是：
- ``minip`` 最低允许的地址；接受: **str**，例如，192.168.0.1； **iterable of numbers**，例如[192,168,.0,1]；**int**，例如，3232235521
- ``maxip`` 最高允许的地址；与上面相同

三个例子的值都相同，因为地址用下面函数变换成整型进行包含检查：
``
number = 16777216 * IP[0] + 65536 * IP[1] + 256 * IP[2] + IP[3]
``:code

例如：
检查IPv4地址合法性：
``
requires = IS_IPV4()
``:code

检查私有网络IPv4地址合法性：
``
requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')
``:code

##### ``IS_LOWER``
``IS_LOWER``:inxx

该验证器从不返回错误。它把值转换为小写字母。
``
requires = IS_LOWER()
``:code

##### ``IS_UPPER``
``IS_UPPER``:inxx

该验证器从不返回错误。它把参数值转换为大写字母。
``
requires = IS_UPPER()
``:code

##### ``IS_NULL_OR``
``IS_NULL_OR``:inxx

过时，是下面描述的``IS_EMPTY_OR`` 的别名

##### ``IS_EMPTY_OR``
``IS_EMPTY_OR``:inxx

有时，你需要允许在字段空值及其它要求。例如，字段是日期但它也能是空。
``IS_EMPTY_OR`` 验证器允许：
``
requires = IS_EMPTY_OR(IS_DATE())
``:code

##### ``CLEANUP``
``CLEANUP``:inxx

这是个过滤器。它从不失效。它就清除所有十进制ASCII代码不在[10,13,32-127]
的字符。
``
requires = CLEANUP()
``:code

##### ``CRYPT``
``CRYPT``:inxx

这也是个过滤器。它把输入执行安全哈希用来防止输入的密码明文传递为数据
库。
``
requires = CRYPT()
``:code

如果密钥没有指定，用MD5算法。如果密钥指定为CRYPT则用HMAC算法。用
HMAC密钥包含前缀确定算法，例如SHA512：

``
requires = CRYPT(key='sha512:thisisthekey')
``:code

这是推荐的语法。密钥必须是关联使用数据库唯一的字符串。密钥不能再修改。如果你丢失了之前哈希密钥，值变得无用。
CRYPT验证器哈希散列输入，这使它有些特殊。如果你需要散列之前，验证密码字段，你能用验证器列表中的CRYPT，必须确定它是列表最后，以便最后调
用。
例如：

``
requires = [IS_STRONG(),CRYPT(key='sha512:thisisthekey')]
``:code

``CRYPT`` also takes a ``min_length`` argument which defaults to zero.

#### 数据库验证器 Database validators

##### ``IS_NOT_IN_DB``
``IS_NOT_IN_DB``:inxx

考虑下面的例子：
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

它要求，当你插入新的person记录，他/她的名字不能已存在数据库， ``db``，字段``person.name``。与其它所有的验证器，这个要求在表单处理级是强制的，不是数
据库级。这意味着，有很小的概率，如果两个访问者试图同时插入相同的person.name记录，这导致了竞争情况，两个记录都被接受了。因此，安全起见
告知数据库这个字段应该有唯一的值。
``
db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

现在如果竞争情况出现，数据库产生OperationalError，两条插入记录之一被拒绝。

``IS_NOT_IN_DB`` 的第一个参数是数据库连接或Set（集合）。后者情况，你仅需检查用Set定义的set对象。
下面的代码，例如，不允许同名的两个人彼此在10天之内注册：
``
import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp>now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')
``:code

##### ``IS_IN_DB``
``IS_IN_DB``:inxx

考虑下面的表和要求：

``
db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
``:code

它在dog INSERT/UPDATE/DELETE表单层级强制实施。它要求``dog.owner``在数据库``db``的字段 ``person.id``有合法id。因为这个验证器，``dog.owner`` 字段呈现为下拉框。
该验证器的第三个参数是字符串，描述下拉框里的元素。例子中，你想看到person``%(name)s`` 而不是person ``%(id)s``. ``%(...)s`` 被每条记录圆括号内的字段值替换。

该校验器的``zero``参数可能是数据库连接或DAL Set，如同``IS_NOT_IN_DB``。当想要限制下拉框记录数，这对于例子会有用。这个例子，每次控制器调用，我们用
控制器中``IS_IN_SET`` 动态限制记录数：


``
def index():
    (...)
    query = (db.table.field == 'xyz') #in practice 'xyz' would be a variable
    db.table.field.requires=IS_IN_DB(db(query),....)
    form=SQLFORM(...)
    if form.process().accepted: ...
    (...)
``:code

如果你想字段验证，但你不想用下拉框，你必须把验证器放在列表：

``
db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]
``:code

``_and``:inxx
偶尔，你想用下拉框（而你不想用上面的列表语法），想用附加的验证器。为了这个目的，``IS_IN_DB``验证器用额外参数``_and``，指向其它验证器列表，如果应用了验证值传递给``IS_IN_DB`` 进行验证。例如验证所有数据库中狗主人不在下面
的子集：
``
subset=db(db.person.id>100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset,'person.id'))
``:code

``IS_IN_DB`` 也用 ``cache`` 参数，作用象select的 ``cache`` 参数。

##### ``IS_IN_DB``和 Tagging
``tags``:inxx
``multiple``:inxx

``IS_IN_DB``验证器有可选属性``multiple=False``。如果设置为``True``，多个值能存在一个字段。这个字段必须是``list:reference``类型，第6章讨论的。Tagging的清晰的例子在那里讨论了。``multiple``引用在创建和更新表单自动处理，但对DAL时透明的。我们强烈建议用JQuery多查询插件呈现多字段。

#### 自定义验证器 Custom validators
``custom validator``:inxx

所有的验证器遵从下面的原型：
``
class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(self, value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)
``:code

即当调用验证一个值时，校验器返回元组``(x, y)``。如果 ``y`` 是 ``None``，那么传递给校验器的值和``x`` 包含解析值。例如，当验证器要求值是整数， ``x`` 转换为``int(value)``。如果值没有通过验证，那么``x`` 包含输入值而 ``y`` 包含错误消息解释验证失
败。这个错误消息用来报告表单中的不合法的错误。

验证器也包含 ``formatter`` 方法。它必须执行与``__call__`` 调用正好相反的转换。例如，考虑``IS_DATE``源代码：
``
class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))
``:code

成功，``__call__`` 方法从表单读取日期字符串，并用构造函数指定的格式字符串把它转换成datetime.date对象。``formatter``对象用datetime.date对象，用同样的格式把它转换为字符串表示。在表单``formatter``自动调用，但你能显式调用它，把对象转换为适当的表示。例如：
``
>>> db = DAL()
>>> db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
>>> id = db.atable.insert(birth=datetime.date(2008, 1, 1))
>>> row = db.atable[id]
>>> print db.atable.formatter(row.birth)
01/01/2008
``:code

当需要多个验证器的时候（存储在列表），它们顺序运行，通过输出作为下一个输入。当其中一个验证器失败，链式运行终止。

反之，当我们调用字段``formatter``方法，相关验证器的formatter也链接起来，但恰好相反的顺序。

------
注意替代定制验证器，你也能用 ``form.accepts(...)``, ``form.process(...)`` 和 ``form.validate(...)````onvalidate``参数。
------


#### 依赖的验证器 Validators with dependencies

通常模型中验证器一次为全部设置。

偶尔，你需要验证字段，而验证器依赖于另外字段的值。这能用各种方法实现。它能在模型中或控制器中实现。

例如，如下页生成注册表单，要求用户名和密码两次。没有字段可以是空，两次密码必须一致：
``
def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_EQUAL_TO(request.vars.password)))
    if form.process().accepted:
        pass # or take some action
    return dict(form=form)
``:code

同样的机制能用在FORM 和 SQLFORM对象。

### Widgets 小工具

下面是可用web2py小工具的列表：
``
SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete
``:code

前十个对相应字段类型是默认的。当字段的要求是``IS_IN_SET`` 或 ``IS_IN_DB``并且``multiple=False``（默认行为），“options”小工具使用。当字段的要求是``IS_IN_SET``或``IS_IN_DB``并且``multiple=False``，“"multiple”小工具使用。“radio”和“checkboxes”默认从不使用，但能手动设置。autocomplete自动完成工具很特殊，在它的章节讨论。


例如，我们有“string”字段用文本域表示：
``
Field('comment', 'string', widget=SQLFORM.widgets.text.widget)
``:code

小工具能指定到字段 ''a posteriori'':

``
db.mytable.myfield.widget = SQLFORM.widgets.string.widget
``

有时，小工具用附加参数，需要指定它们的值。这种情况，可以使用``lambda``

``
db.mytable.myfield.widget = lambda field,value: \
    SQLFORM.widgets.string.widget(field,value,_style='color:blue')
``

idgets是帮助对象制造厂，它们的头两个参数总是``field``和``value``。其它参数包括正常帮助对象属性，如``_style``,``_class``等。一些widgets也用特殊参数。特别是 ``SQLFORM.widgets.radio``和 ``SQLFORM.widgets.checkboxes`` 采用 ``style``参数（不要与``_style``混淆），能设置为“table”、“ul”或“divs”并以所包含表单的 ``formstyle`` 匹配。

你能创建新的widgets或是扩展现有widgets。

``SQLFORM.widgets[type]`` 是类， ``SQLFORM.widgets[type].widget`` 是相应类的静态成员函数。每个widget函数有两个参数：字段对象和字段对象当前值。它返回widget的表示。作为例子， 字符串widget记做下面：
``
def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field._tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)
``:code

id和类的值必须遵守这一章后面描述的习惯。Widget包含自己的校验器，但好的实践是关联字段“requires”属性的校验器，并使widget从那儿得到。

#### 自动完成widget Autocomplete widget
``autocomplete``:inxx

对autocomplete widget有两种可能的用法：从列表自动完成一个字段或自动完成引用字段（自动完成的字符串是引用的表示，用id实现）。
第一种情况容易：
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, limitby=(0,10), min_length=2)
``:code

``limitby`` 指示widget 一次显示不超过10 条建议， ``min_length`` 指示widget 执行Ajax回调得到建议，仅当用户在搜索框敲入至少两个字符。
第二种情况复杂地多：
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)
``:code

这种情况下， ``id_field`` 的值告诉widget，即使自动完成的值是``db.category.name``, 存储的值也是相应``db.category.id``。可选参数是``orderby``，指示widget如何对建议排序（默认字母顺序）。

Widget通过Ajax工作。Ajax在哪回调？这个widget有些神奇。回调是widget对象自己的方法。它如何显露？web2py任何代码生成响应引发HTTP异常。Widget用下
面的方式利用这种可能性：widge给Ajaxt发送调用，对同一个URL，第一个位置生成widge，把特殊令牌放在request.vars。widge再次实例化，它发现令牌，并
引发HTTP异常以响应请求。所有这些在后台完成，对编程者隐藏。

### ``SQLFORM.grid``和 ``SQLFORM.smartgrid`` （实验性的）

两个高级工具创建复杂CRUD控制。它们提供分页，以及从单个工具，浏览、搜索、排序、创建、更新和删除记录的能力，两个中最简单是``SQLFORM.grid``。下面是使用的例子：

``
@auth.requires_login()
def manage_users():
    grid = SQLFORM.grid(db.auth_user)
    return locals()
``

产生如下页面：

[[image @///image/en6700.png center 480px]]

 ``SQLFORM.grid`` 的第一个参数是表或查询。网格工具提供匹配查询的记录访问。在我们开始网格工具参数长列表的参数之前，我们需要理解它如何工作。工具查看``request.args``决定做什么（浏览、搜索、创建、更新和删除等）。每个由工具所创建的按钮链接同样的函数（上面情况的``manage_users``），
但传递不同的``request.args``。默认情况，网格生成所有的URL是数字签名并被验证的。这意味着不登录，不能执行某些动作（创建、更新、删除）。这些限制能象如下解除：

``
def manage_users():
    grid = SQLFORM.grid(db.auth_user,user_signature=False)
    return locals()
``

但我们不推荐使用。

-----
因为网格工作的方式，每人只能有一个网格每个控制器函数，除非通过``LOAD``作为组件嵌入。
-----

因为包含网格的函数能自己操作命令行参数，网格需要知道那个参数该被网格处理哪个不该。例如，下面是允许管理任何表的代码例子：

``
@auth.requires_login()
def manage():
    table = request.args(0)
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.grid(db[table],args=request.args[:1])
    return locals()
``

 ``grid``的``args`` 参数指定哪个 ``request.args`` 该被一起传递，并被工具忽略。这个例子，``request.args[:1]`` 是我们想要管理的表的名字，它被 ``manage`` 函数自己处理，而不是工具。
完整的网格grid用法描述如下：

``
SQLFORM.grid(query,
             fields=None,
             field_id=None,
             left=None,
             headers={},
             orderby=None,
             searchable=True,
             sortable=True,
             deletable=True,
             editable=True,
             details=True,
             create=True,
             csv=True,
             paginate=20,
             selectable=None,
             links=None,
             upload = '<default>',
             args=[],
             user_signature = True,
             maxtextlengths={},
             maxtextlength=20,
             onvalidation=None,
             oncreate=None,
             onupdate=None,
             ondelete=None,
             sorter_icons=('[^]','[v]'),
             ui = 'web2py',
             showbuttontext=True,
             search_widget='default',
             _class="web2py_grid",
             formname='web2py_grid',
             ignore_rw = False,
             formstyle = 'table3cols'):
``:code

- ``fields`` 是从数据库得到的字段列表。它也用来决定哪些字段显示在网格视图。
- ``field_id`` 必须是用作表的ID字段，例如``db.mytable.id``。
- ``headers`` 是字典，映射‘tablename.fieldname’到相应头标签。
- ``orderby`` 为行做默认排序。
- ``searchable``, ``sortable``, ``deletable``, ``details``, ``create`` 分别决定是否能search, sort,delete, view details, 和 create 新记录。
- ``csv`` 如果设置为true，允许以CSV格式下载grid。
- ``paginate`` 设置每页最大的行数。
- ``links`` 用来显示新列，链接到其它页面。``links``参数必须是dict 字典列表 ``dict(header='name',body=lambda row: A(...))`` ，``header`` 是新列的头，``body`` 是函数带row参数有返回值。例子中，值是 ``A(...)``帮助对象。
- ``maxtextlength`` 设置在grid视图中，每个字段值显示的文本最大长度。对每个字段，这个值能用 ``maxtextlengths``覆盖，‘tablename.fieldname’的字典：
length。
- ``onvalidation``, ``oncreate``, ``onupdate`` 和``ondelete`` 是回调函数。除了``ondelete`` 所有函数用表单对象作为输入
- ``sorter_icons`` 是两个字符串列表（或帮助对象），用来表示每个字段升和降
序排序的选项。
- ``ui`` 能设置为‘web2py’，将生成web2py友好的类名，能设置为``jquery-ui`` ，将生成jquery UI友好的类名，它也可以是为各种grid组件的自己的类名集。

``
ui = dict(widget='',
          header='',
          content='',
          default='',
          cornerall='',
          cornertop='',
          cornerbottom='',
          button='button',
          buttontext='buttontext button',
          buttonadd='icon plus',
          buttonback='icon leftarrow',
          buttonexport='icon downarrow',
          buttondelete='icon trash',
          buttonedit='icon pen',
          buttontable='icon rightarrow',
          buttonview='icon magnifier')
``:code

- ``search_widget`` 允许超越默认搜索工具，我们推荐读者参考“gluon/sqlhtml.py”中的源代码获得细节。
- ``showbutton`` 允许关闭所有按钮。
- ``_class`` 是为grid容器的类。
- ``formname``, ``ignore_rw`` 和 ``formstyle`` 传递给SQLFORM对象，被创建/更新表单grid使用。

------
``deletable``, ``editable``和 ``details`` 通常是布尔值，但也可以是函数，用row对象参数，决定是否显示相应按钮。
-----

``SQLFORM.smartgrid`` 看起来很像 ``grid``，实际上它包含网格，但它设计用来作为输入而不是查询就只一张表格，以及浏览said（所述？）表并查询引用表格。
例如，考虑下表结构：

``
db.define_table('parent',Field('name'))
db.define_table('child',Field('name'),Field('parent','reference parent'))
``:code

用SQLFORM.grid，你能列出所有父parent：

``
SQLFORM.grid(db.parent)
``:code
所有孩子：
``
SQLFORM.grid(db.child)
``:code
一张表列出所有的父与子：
``
SQLFORM.grid(db.parent,left=db.child.on(db.child.parent=db.parent.id))
``:code

用SQLFORM.smartgrid，你能把所有数据放在一个工具内派生这些表：

``
@auth.requires_login():
def manage():
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
``:code

看起来如下：

[[image @///image/en6800.png center 480px]]

注意额外的“"children”链接。可用规则的``grid``创建额外的``links`` ，但它们指向不同的动作。用``smartgrid`` ，它们被同一个工具自动创建和处理。

也注意，当点击给定父类的“children”链接，只能得到那个父类的子的列表（这是显然的），也注意如果试图添加新的子，父类的值为新的子自动设置
为查询父类（显示在关联到工具的breadcrumbs）。这个字段的值能被覆盖。我们能通过设置它只读来防止：

``
@auth.requires_login():
def manage():
    db.child.parent.writable = False
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
``:code

如果 ``linked_tables`` 参数没有指定，所有引用表自动链接。尽管这样，为了避免意外公开数据，我们推荐显示列出要链接的表格。
下面的代码为系统中的表创建非常有力的管理界面：

``
@auth.requires_membership('managers'):
def manage():
    table = request.args(0) or 'auth_user'
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.smartgrid(db[table],args=request.args[:1])
    return locals()
``:code

``smartgrid`` 与 ``grid``用同样的参数，更多注意事项：

- 第一个参数是表，不是查询。
- 有额外参数 ``constraints`` ，包含‘tablename’字典：query，用于更多限制访问显示在‘tablename’grid的记录。
- 有额外参数``linked_tables`` ，通过smartgrid访问的表的表名的列表。
- 所有的参数除了table, ``args``, ``linked_tables`` 和``user_signatures`` 都能是解释如下的字典。思考之前的grid：
``
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
``
它允许访问``db.parent`` 和 ``db.child``除了为导航控制，对每个表，smarttable不是别的就是grid。这意味着，这种情况，smartgrid能给父创建grid，给子创建grid。我
们想传递不同的参数及给这些grid。例如，不同的``searchable`` 参数集。而对grid，我们传递布尔值： 
``
grid = SQLFORM.grid(db.parent,searchable=True)
``
对smartgrid，我们传递布尔值字典：
``
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'],
     searchable= dict(parent=True, child=False))
``
这样，我们使父可搜索，但父的子不能搜索（也不该有那么多搜索工具）。


-------
grid和smartgrid小工具就停留在这，但它们标识为实验阶段，因为它们返回实际的html布局以及能传递给他们的确切参数集，当新功能加入，可能会改变。
-------


``grid`` 和 ``smartgrid`` 象crud一样不会自动实现访问控制，但你能用 ``auth`` 通过显式许可检查集成：

``
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_membership('managers'),
     deletable = auth.has_membership('managers'))
``

或

``
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_permission('edit','auth_user'),
     deletable = auth.has_permission('delete','auth_user'))
``

``smartgrid`` 是web2py仅有的小工具，显示表名，它需要单数和复数。例如，父能有单个“Child”或许多“Children”。因此表对象需要知道它自己单数和复数名。
web2py一般猜测它们，但你能显式设置：

``
db.define_table('child', ..., singular="Child", plural="Children")
``:code

或者用: ``singular``:inxx ``plural``:inxx

``
db.define_table('child', ...)
db.child._singular = "Child"
db.child._plural = "Children"
``:code

它们也该用``T``
然后复数和单数值被``smartgrid``用来为头和链接提供正确的名字。 
