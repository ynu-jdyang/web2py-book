## 核心

### 命令行选项

可以跳过GUI直接从命令行启动web2py，方法如下：
``password``:inxx

``
python web2py.py -a 'your password' -i 127.0.0.1 -p 8000
``:code

当web2py启动时，它会创建一个文件名为"parameters_8000.py"，其中存储散列的密码。如果你使用密码“<ask>”，web2py会提示你。

为了额外安全性，你可以如下启动web2py：
``
python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000
``:code

在这种情况下， web2py 重用以前存储的哈希密码。如果没有提供密码或"parameters_8000.py"文件被删除，基于web的管理界面会被禁用。

``PAM``:inxx
一些Unix/ Linux系统上，如果密码是
``
<pam_user:some_user>
``:code

web2py的使用操作系统帐户some_user的PAM密码来认证管理员，除非由PAM配置阻止。

-------
web2py通常运行CPython（Python解释器的C语言实现由Guido van Rossum创建），但它也能运行Jython（解释器的Java实现）。后面的可能性允许在J2EE基础架构的情况下使用的web2py。使用Jython，只需更换"python web2py.py ..."为"jython web2py.py"。
可以在第14章中找到关于安装Jython和访问数据库需要的zxJDBC模块的详细信息。

-------

"web2py.py"脚本可以采取许多命令行参数，指定最大线程数，启用SSL等。如下获取完整列表：

``command line``:inxx
``
>>> python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        ip address of the server (127.0.0.1)
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "<recycle>" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  -f FOLDER, --folder=FOLDER
                        folder from which to run web2py
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created).  Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps
                        -K app1, app2, app3 requires a scheduler defined in the
                        models of the respective apps
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -W WINSERVICE, --winservice=WINSERVICE
                        -W install|start|stop as Windows service
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -N, --no-cron         do not start cron automatically
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses:
                        "ip:port:cert:key;ip2:port2:cert2:key2;..." (:cert:key
                        optional; no spaces)
``:code

小写选项用于配置web服务器。``-L``选项告诉web2py从文件中读取配置选项，``-W`` 安装web2py作为一个Windows服务，而``-S``，``-P``和``-M``选项启动交互式Python shell。``-T``选项发现并在web2py执行环境中运行控制器doctests。例如，下面的例子从"welcome"应用中的所有控制器运行doctests：
``
python web2py.py -vT welcome
``:code

如果你运行web2py作为Windows服务，``-W``W，通过使用命令行参数传递配置是不方便的。出于这个原因，web2py文件夹中有一个样本"options_std.py"内部web服务器配置文件：

``
import socket
import os

ip = '0.0.0.0'
port = 80
interfaces=[('0.0.0.0',80)]
#interfaces.append(('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem'))
password = '<recycle>'  # ## <recycle> means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None
``:code

这个文件包含了web2py的默认。如果你编辑这个文件，你需要用``-L``命令行选项明确地导入它。作为一个Windows服务运行web2py，它才适用。

### 工作流

web2py工作流如下：
- HTTP请求到达web服务器（内置Rocket服务器或通过WSGI连接到web2py的不同服务器或另外的适配器）。该web服务器在其自己的线程，并行处理每个请求。
- HTTP请求标头被解析并传递到调度器（在本章稍后解释）。
- 调度器将决定由哪一个已安装应用处理请求，并把URL中的PATH_INFO映射成函数调用。每个URL对应一个函数调用。
- 对于静态文件夹中文件的请求被直接处理，并且大文件被自动流式传输到客户端。
- 除静态文件之外的请求被映射成动作（即请求应用控制器中的一个函数）。
- 调用动作之前，发生的几件事：如果请求标头包含应用的会话cookie，会话对象被恢复；如果没有，会话id被创建（但会话文件直到后来才被保存）；创建请求的执行环
境；在这种环境下执行模型。
- 最后，控制器动作在预先构建的环境中执行。
- 如果动作返回一个字符串，它被返回客户端（或者如果该动作返回一个web2py的HTML帮助对象，它被序列化并返回给客户端）。
- 如果动作返回一个可迭代工作流，它被用来循环并将数据分流传送到客户端。
- 如果动作返回一个字典，web2py会试图找到一个视图呈现该字典。视图必须与动作名称相同（除非另有规定）并且扩展名与被请求的页面相同（默认为.html）；失败的话，
web2py可能采用通用视图（如果可用并且已启用）。视图看到定义在模型中和由动作返回的字典中的每个变量，但没有看到在控制器中定义的全局变量。
- 整个用户代码在单一事务中执行，除非另有规定。
- 如果用户代码成功，事务被提交。
- 如果用户代码失败，回溯被存储在票据中，票据ID被发送给客户端。只有系统管理员能搜索和阅读票据中的回溯。

有一些注意事项要牢记：
- 同一文件夹/子文件夹中的模型按字母顺序执行。
- 模型中定义的任何变量对字母顺序排在后面的模型、控制器和视图都是可见的。
- 子文件夹中的模型被有条件的执行。例如，如果用户请求"/a/c/f"，"a"是应用，"c"是控制器，"f"是函数（动作），那么如下模型会被执行：

``
applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py
``

- 请求的控制器被执行并且请求的函数被调用。这意味着控制器中的所有顶层代码在每个对该控制器请求中被执行。
- 只有动作返回一个字典时，视图才被调用。
- 如果找不到视图，web2py会试图使用通用视图。默认情况下，通用视图被禁用，
虽然'welcome'应用在/models/db.py包含一行代码在localhost上启用它们。可以每
个扩展名每个动作的启用它们（使用``response.generic_patterns``patterns）。一般来说，通用视图是一个开发工具，通常不应在生产中使用。如果你想让某些动作使用通用视图，将那些动作列在``response.generic_patterns``中（更多细节在Services章节中讨论）。

动作的可能行为有以下几种：

**Return a string**
``
def index(): return 'data'
``

**Return a dictionary for a view**:
``
def index(): return dict(key='value')
``

**Return all local variables**:
``
def index(): return locals()
``

**Redirect the user to another page**:
``
def index(): redirect(URL('other_action'))
``

**Return an HTTP page other than "200 OK"**:
``
def index(): raise HTTP(404)
``

**Return a helper** (for example, a FORM):
``
def index(): return FORM(INPUT(_name='test'))
``
（这主要用于Ajax回调和组件，请参阅第12章）

当动作返回一个字典，其中可能包含帮助对象生成的代码，包括基于数据库表的表单或来自工厂的表单，例如：

``
def index(): return dict(form=SQLFORM.factory(Field('name')).process())
``
(all forms generated by web2py use postbacks, see chapter 3)

### 调度
``url mapping``:inxx ``dispatching``:inxx

web2py将映射形式如下的URL：

``
http://127.0.0.1:8000/a/c/f.html
``:code

到应用"a"控制器"c.py"中的函数``f()``。
如果``f``不存在，web2py默认使用``index`` 控制器函数。
如果``c``不存在，web2py默认使用"default.py"控制器，并且如``a``不存在，web2py默认使用 ``init`` 应用。
如果没有``init`` 应用，web2py尝试运行``welcome`` 应用。示意图如下：

(默认应用、控制器和函数的名称可以在routes.py中重写；
''[[Default Application, Controller and Function #Default-Application,-Controller-and-Function]]'' .

[[image @///image/en5700.png center 480px]]

按照默认，任何新请求都创建一个新会话。除此之外，会话cookie被返回客户端浏览器来追踪会话。

扩展名``.html``是可选的；``.html``被假定为默认。该扩展名决定了用于呈现控制器函数``f()``的输出的视图的扩展名。它允许以多种格式(html、xml、json、rss等)服务相同的内容。

-------
带参数或双下划线开始的函数是不公开的并且只能由其它函数调用。
-------

``static files``:inxx
如下形式的URL例外：
``
http://127.0.0.1:8000/a/static/filename
``:code

没有被称为"static"的控制器。web2py 把这解释成请求应用"a"子文件夹"static"中名为"filename"的文件。

``PARTIAL CONTENT``:inxx ``IF_MODIFIED_SINCE``:inxx
当静态文件被下载了，web2py并不创建会话，也不发出cookie或执行模型。web2py总是以1MB 的块数据流静态文件，并且当客户端发送RANGE 请求文件的一个子集时，发送
PARTIAL CONTENT。

web2py还支持IF_MODIFIED_SINCE协议，如果文件已经存储在浏览器缓存中并且版本没有改变就不发送文件。

当链接到静态文件夹中的一个音频或视频文件时，如果你想强制浏览器下载文件，而不是通过媒体播放器的音频/视频流，将``?attachment``添加到URL。这告诉web2py将``Content-Disposition``标头设置为"attachment"。例如：

``
<a href="/app/static/my_audio_file.mp3?attachment">Download</a>
``:code

当上面的链接被点击后，浏览器会提示用户下载MP3文件，而不是立即流媒体音频。（正如[[below #response]], y所讨论，你还可以直接设置HTTP 请求标头只需分配标头``dict`` 和它们的值给 ``response.headers``.）

``request.application``:inxx ``request.controller``:inxx ``request.function``:inxx ``GET``:inxx ``POST``:inxx ``request.args``:inxx
web2py映射如下形式的GET/POST请求：
``
http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&q=2
``:code

到应用``a``控制器"c.py"中的函数``f``，并且它在``request``变量中存储URL参数如下：
``
request.args = ['x', 'y', 'z']
``:code

和：
``
request.vars = {'p':1, 'q':2}
``:code

以及：
``
request.application = 'a'
request.controller = 'c'
request.function = 'f'
``:code

在上面的例子中，``request.args[i]``和``request.args(i)``都能用来检索``request.args``的第i个元素，如果列表没有这样的索引，前者会引发异常，后者在这种情况下返回None。

``request.url``:inxx
``
request.url
``:code

存储当前请求的完整URL（不包括GET变量）。

``request.ajax``:inxx ``request.cid``:inxx

``
request.ajax
``:code

默认为False，但如果web2py决定动作是Ajax请求调用的，它就是True。

如果请求是Ajax请求并且是由web2py组件发起的，可以如下找到该组件的名称：

``
request.cid
``:code

在第12章详细讨论了组件。

``request.get_vars``:inxx ``request.post_vars``:inxx ``request.vars``:inxx
如果HTTP请求是一个GET，那么``request.env.request_method``被设置为"GET"；如果它是一个POST，``request.env.request_method``被设置为"POST"。URL查询变量存储在``request.vars`` 存储字典中；它们还存储在 ``request.get_vars`` （跟随GET 请求）或 ``request.post_vars`` （跟随POST请求）。

web2py在``request.env``中存储WSGI和web2py环境变量，例如：
``
request.env.path_info = 'a/c/f'
``:code

和HTTP标头到环境变量，例如：
``
request.env.http_host = '127.0.0.1:8000'
``:code

-------
请注意，web2py的验证所有的URL以防止目录遍历攻击。
-------

URL只允许包含字母数字字符，下划线和斜线；``args``可以包含非连续点。验证前空格替换为下划线。
如果是无效的URL语法，web2py会返回一个HTTP400错误消息``http:w,http:o``

如果该URL对应一个静态文件请求，web2py简单的读取和返回（流式传输）请求的文件。

如果URL不请求静态文件，web2py按以下顺序处理要求：
- 解析cookie
- 创建一个环境，在其中执行函数。
- 初始化 ``request``， ``response``， ``cache``。
- 打开现有``session`` 或创建一个新的。
- 执行属于请求应用的模型。
- 执行请求的控制器动作函数。
- 如果该函数返回一个字典，执行相关的视图。
- 如果成功，提交所有开放事务。
- 保存会话。
- 返回一个HTTP响应。

请注意，控制器和视图在同样环境的不同副本下执行；因此，视图不会看到控制器，但它会看到模型并且它能看到控制器动作函数返回的变量。

如果引发异常（非HTTP），web2py会执行以下操作：
- 将回溯存储在一个错误文件中并为它分配一个票据号。
- 回滚所有开放事务。
- 返回一个报告票据号的错误页面。

如果异常是``HTTP``异常，这被认为是预期行为（例如，一个``HTTP``重定向），并且所有数据库事务被提交。此后的行为由``HTTP``异常本身指定。``HTTP``异常类不是标准的Python异常，它是由web2py定义的。

### 库

web2py 库作为全局对象公开给用户应用。例如（``request``， ``response``， ``session``， ``cache``），类 （helper帮助对象，validator验证器，DAL API）和函数（``T`` 和 ``redirect``）。

这些对象定义在以下核心文件中：
``
web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py
``:code

web2py附带的tar gzip（解包解压缩）基本构建应用是：
``
welcome.w2p
``:code

它在安装时被创建升级时被覆盖。

-------
你第一次启动web2py时，创建两个新文件夹：deposit和applications。"welcome"应用被压缩成"welcome.w2p"文件，作为基本构建应用来使用。deposit文件夹用来作为安装和卸载应用的临时存储。
-------

web2py的单元测试是在
``
gluon/tests/
``:code

有与各种web服务器连接的处理程序：
``
cgihandler.py       # discouraged
gaehandler.py       # for Google App Engine
fcgihandler.py      # for FastCGI
wsgihandler.py      # for WSGI
isapiwsgihandler.py # for IIS
modpythonhandler.py # deprecated
``:code

（"fcgihandler"调用由Allan Saddi 开发的"gluon/contrib/gateways/fcgi.py"）和

``
anyserver.py
``

这是一个与许多不同Web服务器接口的脚本，第13章介绍。

有3个示例文件：
``
options_std.py
routes.example.py
router.example.py
``:code

前者是一个可选的配置文件，可以通过``-L``选项传递给web2py.py。第二个是一个URL映射文件的例子。当重命名为"routes.py"它会自动加载。第三个是一个URL映射的替代语法，也可以重命名（或复制到）"routes.py"。


文件
``
app.yaml
index.yaml
queue.yaml
``:code

是用来在Google AppEngine上部署的配置文件。可以在DeploymentRecipes章节和Google Documentation页面阅读更多关于它们的内容。

还有附加的库，通常由第三方开发：

 Mark Pilgrim开发的读取RSS和Atom feeds的**feedparser**``feedparser``:cite
``
gluon/contrib/__init__.py
gluon/contrib/feedparser.py
``:code

Trent Mick开发的用于wiki标记的**markdown2**``markdown2``:cite  
``
gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py
``:code

**markmin** 标记：
``
gluon/contrib/markmin.py
``:code

Mariano Reingart创建的生成PDF文档的**pyfpdf** 
``
gluon/contrib/pyfpdf
``
本书中没有对此介绍，对它的介绍在如下位置：
``
http://code.google.com/p/pyfpdf/
``

**pysimplesoap** 是由Mariano Reingart创建的一个轻量级的SOAP服务器实现：

``
gluon/contrib/pysimplesoap/
``:code

**simplejsonrpc** 是由Mariano Reingart创建的一个轻量级的JSON-RPC客户端： ``jsonrpc``:inxx

``
gluon/contrib/simplejsonrpc.py
``

Evan Martin开发的**memcache**``memcache``:cite  Python API:
``
gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py
``

**redis_cache** 是一个在``redis``数据库中存储缓存的模块：
``
gluon/contrib/redis_cache.py
``

**gql**，Google App Engine的DAL端口：
``
gluon/contrib/gql.py
``:code

**memdb**，memcache顶部的一个DAL端口：
``
gluon/contrib/memdb.py
``:code

**gae_memcache** 是一个在Google App Engine上使用memcache的API：
``
gluon/contrib/gae_memcache.py
``:code

**pyrtf**``pyrtf``:cite  生成RTF格式文件，由Simon Cusack开发，Grant Edwards修订：
``
gluon/contrib/pyrtf
gluon/contrib/pyrtf/__init__.py
gluon/contrib/pyrtf/Constants.py
gluon/contrib/pyrtf/Elements.py
gluon/contrib/pyrtf/PropertySets.py
gluon/contrib/pyrtf/README
gluon/contrib/pyrtf/Renderer.py
gluon/contrib/pyrtf/Styles.py
``:code

DalkeScientificSoftware开发的**PyRSS2Gen**``pyrss2gen``:cite用于生成RSS订阅：
``
gluon/contrib/rss2.py
``:code

**simplejson**``simplejson``:cite  是由Bob Ippolito开发的用于分析和编写JSON对象的标准库：
``
gluon/contrib/simplejson/__init__.py
gluon/contrib/simplejson/decoder.py
gluon/contrib/simplejson/encoder.py
gluon/contrib/simplejson/jsonfilter.py
gluon/contrib/simplejson/scanner.py
``:code

**Google Wallet** ``googlewallet``:cite 
提供 "pay now"按钮，链接谷歌作为付款处理器：
``
gluon/contrib/google_wallet.py
``:code

**Stripe.com** ``stripe``:cite 提供一个简单的API接受信用卡付款：
``
gluon/contrib/stripe.py
``:code

**AuthorizeNet** ``authorizenet``:cite  提供API通过Authorize.net网络接收信用卡付款
``
gluon/contrib/AuthorizeNet.py
``:code

**Dowcommerce** ``dowcommerce``:cite 是另一个信用卡购物车处理API：
``
gluon/contrib/DowCommerce.py
``:code

Chris AtLee创建的**PAM**``PAM``:cite  验证API：
``
gluon/contrib/pam.py
``:code

一个贝叶斯分类器，为了测试目的用虚拟数据填充数据库：
``
gluon/contrib/populate.py
``:code

当web2py作为服务运行时，允许与Windows任务栏交互的一个文件：
``
gluon/contrib/taskbar_widget.py
``:code

可选的**login_methods**和login_forms用于身份认证：

``
gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py
``:code

web2py还包括一个包含如下有用脚本的文件夹
``
scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py
``:code

前三个尤其有用，因为它们从头开始尝试完整的安装和设置一个web2py生产环境。其中一些在第14章中讨论的，但它们里面都包含一个文档字符串解释用途和用法。

最后，web2py包含建立二进制发行版需要的文件。
``
Makefile
setup_exe.py
setup_app.py
``:code

**py2exe**和**py2app**分别有设置脚本，只有建立web2py的二进制发行版时才需要它们。你应该从来不需要运行它们。

总之，web2py库提供以下功能：
- 将URL映射成函数调用。
- 通过HTTP处理传递和返回参数。
- 执行这些参数的验证。
- 从大多数安全问题保护应用。
- 处理数据持久性（数据库，会话，缓存，cookie）。
- 为各种支持的语言执行字符串翻译。
- 以编程方式生成HTML（例如，从数据库表）。
- 通过数据库抽象层（DAL）生成SQL。
- 生成Rich Text Format格式（RTF）输出。
- 从数据库表中生成逗号分隔值（CSV）输出。
- 生成简易信息聚合（RSS）订阅。
- 为Ajax生成JavaScript对象符号（JSON）序列化字符串。
- wiki标记（Markdown）转换为HTML。
- 公开XML-RPC web服务。
- 通过流媒体上传和下载大文件。

web2py应用包含其它文件，特别是第三方JavaScript库，例如jQuery，calendar/datepicker，EditArea和nicEdit。文件本身都承认它们的作者。

### 应用程序

web2py中开发的应用由以下几部分组成：
- **models** 描述数据库表的数据表示和表之间的关系。
- **controllers** 描述应用逻辑和工作流。
- **views** 描述应如何使用HTML和JavaScript将数据呈现给用户。
- **languages** 描述如何将应用中的字符串翻译成各种受支持的语言。
- **static files** 件不需要处理（例如图像、CSS样式表等）。
- **ABOUT** 和 **README** 文件是不言自明的。
- **errors** 存储应用生成的错误报告。
- **sessions** 存储有关每个特定用户的信息。
- **databases** 存储SQLite数据库和其它表的信息。
- **cache** 存储缓存的应用项目。
- **modules** 是其它可选的Python模块。
- **private** 文件通过控制器访问而不是由开发者直接访问。
- **uploads**文件由模型访问而不是由开发者直接访问
（例如，由应用用户上传的文件）。
- **tests** 是一个目录用来存储测试脚本，装置和mock对象。

模型，视图，控制器，语言和静态文件的访问是通过web管理[design]界面。ABOUT,
README, 和errors也可以通过相应的菜单项经由管理界面访问。Sessions, cache, modules 和private文件可以由应用访问但不能通过管理界面访问。

一切都整齐地在组织在一个明确的目录结构中，每个已安装的web2py应用都复制该结构，虽然用户永远不需要直接访问文件系统：

``about``:inxx ``license``:inxx ``cache``:inxx ``controllers``:inxx ``databases``:inxx ``errors``:inxx ``languages``:inxx ``models``:inxx ``modules``:inxx ``private``:inxx ``session``:inxx ``static``:inxx ``tests``:inxx ``uploads``:inxx ``views``:inxx ``__init__.py``:inxx
``
__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static
``:code

"__init__.py" 是一个空文件，这是为了让Python（和web2py）导入``modules`` 目录中的模块。

请注意，**admin**应用只是为服务器文件系统上的web2py应用提供一个web接口。也可以从命令行创建和开发web2py应用；你不必使用浏览器**admin**界面。复制上面的目录结构到例如"applications/newapp/"下（或者简单的将``welcome.w2p``文件解压到新的应用目录），可以手动创建一个新的应用程序。也可以从命令行创建和编辑应用文件而不必使用web**admin** 界面。

### API

在已经为我们导入以下对象的环境中执行模型，控制器和视图:

**Global Objects:** ``request``:inxx ``response``:inxx ``session``:inxx ``cache``:inxx

``
request, response, session, cache
``:code

**Internationalization:** ``T``:inxx ``internationalization``:inxx

``
T
``:code

**Navigation:** ``redirect``:inxx ``HTTP``:inxx

``
redirect, HTTP
``:code


**Helpers:** ``helpers``:inxx

``
XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON
``:code

**Forms and tables**

``
SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)
``

**Validators:** ``validators``:inxx

``
CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL
``:code

**Database:** ``DAL``:inxx

``
DAL, Field
``:code

为了向后兼容``SQLDB=DAL``和``SQLField=Field``。我们鼓励你使用新的语法``DAL`` 和``Field``，而不是旧的语法。 

我们的对象和模块定义在库中，但不会自动导入它们因为并不经常使用。

web2py 执行环境中的核心API 实体包括``request``，``response``，``session``， ``cache``， ``URL``，``HTTP``，``redirect``和``T``，并在下面讨论。


几个对象和函数包括**Auth**，**Crud**和**Service**定义在指在"gluon/tools.py" 中，用的时候需要导入它们：

``
from gluon.tools import Auth, Crud, Service
``:code

#### 从Python模块访问API

你的模型或控制器可以导入Python模块，而这些可能需要使用一些web2py的API。它们这样做的方式是导入：

``
from gluon import *
``

事实上，任何Python 模块即使不由web2py 应用导入，可以导入web2py 的API 只要web2py在``sys.path``中。

但有一点需要注意。web2py中定义了一些全局对象(request, response, session, cache,T)（请求，响应，会话，缓存，T），只能存在于HTTP请求存在（或伪造）时。因此，只有当它们被应用调用时模块才可以访问它们。出于这个原因，它们被放置到一个叫做``current``的容器中，这是一个线程局部对象。例如。

创建一个模块"/myapp/modules/test.py"，其中包含：
``
from gluon import *
def ip(): return current.request.client
``
现在，在"myapp"的控制器中你可以作如下操作：
``
import test
def index():
    return "Your ip is " + test.ip()
``

请注意以下几点：

- ``importtest``首先在当前应用的模块文件夹中寻找模块，之后在``sys.path``列出的文件夹中寻找。因此，应用级模块总是优先于Python模块。这允许不同应用附带它们不同版本的模块，而不会发生冲突。

- 不同的用户可以同时调用相同的 ``index`` 动作，它调用模块中的函数，而且不会有任何冲突因为``current.request``是处在不同线程中的不同对象。只是要小心，不要在模块的函数或类（即顶层）之外访问``current.request`` 

- ``import test`` t是从 ``from applications.appname.modules import test``. 导入test的快捷方式。使用较长的语法，可以从其它应用导入模块。

F为了与普通Python行为的一致性，默认情况下，进行更改时web2py不会重新加载模块。然
而，这是可以改变的。要开启自动重载模块功能，如下使用``track_changes`` 函数（通常在一个模型文件中，在任何导入之前）：

``
from gluon.custom_import import track_changes; track_changes(True)
``:code

从现在起，每次导入模块，导入器都将检查Python源文件(.py)是否已经改变。如果它改变了，模块将被重载。这适用于所有Python模块，甚至是web2py外的模块。该模式是全局性
的，适用于所有应用。无论使用何种模式，总是重新加载模型，控制器和视图的更改。要关闭该模式，使用以 ``False``为参数的相同函数。要了解实际的跟踪状态，使用
``is_tracking_changes()``函数，也来自于``gluon.custom_import``。


导入``current``的模块可以访问：
- ``current.request``
- ``current.response``
- ``current.session``
- ``current.cache``
- ``current.T``
以及其它任何应用选择存储在current中的变量。例如一个模型可以做

``
auth = Auth(db)
from gluon import current
current.auth = auth
``

现在导入的所有模块都可以访问

- ``current.auth``

``current``和``import``建立一个强大的机制，为你的应用构建可扩展和可重用的模块。

-------
有一个主要的警告。给定``from gluon import current``，使用 ``current.request`` 和任何其他线程本地对
象是正确的，但不应该将它们分配给模块中的全局变量，如
``
request = current.request # WRONG! DANGER!
``
也不能把它分配给类属性
``
class MyClass:
    request = current.request # WRONG! DANGER!
``
这是因为线程本地对象必须在运行时提取。
而全局变量只在模型第一次导入时定义一次。
-------


### ``request``请求对象
``request``:inxx ``Storage``:inxx ``request.cookies``:inxx ``user_agent``:inxx

 ``request`` 对象是一个无处不在的被称为``gluon.storage.Storage``的web2py类的实例。Storage扩展Python的 ``dict`` 类。它基本上是一本字典，但项目的值也可以作为属性访问：
``
request.vars
``:code

是一样的：
``
request['vars']
``:code

与字典不同，如果属性（或key）不存在，不会引发异常。相反，它会返回``None``.

-----
有时创建自己的Storage（存储）对象是有用的。你可以如下操作：
``
from gluon.storage import Storage
my_storage = Storage() # empty storage object
my_other_storage = Storage(dict(a=1, b=2)) # convert dictionary to Storage
``:code
-----

``request`` 有以下项目/属性，其中有一些也是``Storage`` 类的实例：
- ``request.cookies``:``Cookie.SimpleCookie()``对象包含
HTTP请求传递的cookie。它行为像一个cookie字典。
每个cookie就是一个Morsel对象。
-``request.env``:``Storage``对象包含传递到控制器的环境变量，包括来自HTTP请求的HTTP标头变量和WSGI参数。环境变量都转换成小写，点转换成下划线，便于记忆。
- ``request.application``: 所请求应用的名称（从``request.env.path_info``解析）。
- ``request.controller``: 所请求控制器的名称（从``request.env.path_info``解析）。
- ``request.function``: 所请求函数的名称 （从``request.env.path_info``解析）。
- ``request.extension``: 所请求动作的扩展。默认是"html"。如果控制器函数返回一个字典并且没有指定视图，这用来确定呈现字典的视图文件的扩展名（从``request.env.path_info``解析）。
- ``request.folder``:应用目录。例如如果应用是"welcome"``request.folder`` 设置到绝对路径"/path/to/welcome"。在你的程序中，你应该始终使用这个变量和os.path.join函数来构建你需要访问的文件的路径。尽管web2py始终使用绝对路径，一个好的规则是从不明确改变当前工作文件夹（不管它是什么）因为这不是一个线程安全的做法。
- ``request.now``:  ``datetime.datetime`` 对象存储当前请求的日期时间。
- ``request.utcnow``: 一个``datetime.datetime`` 对象存储当前请求的UTC日期时间。
- ``request.args``: 控制器函数名称之后的URL路径组件列表；等同于``request.env.path_info.split('/')[3:]``
- ``request.vars``: 一个``gluon.storage.Storage`` 对象包含HTTP GET和HTTP POST查询变量。
- ``request.get_vars``: 一个``gluon.storage.Storage``对象只包含HTTP GET查询变量。
- ``request.post_vars``: 一个``gluon.storage.Storage`` 对象只包含HTTP POST查询变量。
- ``request.client``: 客户端的ip地址，如果存在的话，由``request.env.http_x_forwarded_for`` 确定或否则的话由``request.env.remote_addr``确定。虽然这是有用的，但不应该信任它，因为``http_x_forwarded_for`` 可以被欺骗。
- ``request.is_local``: 客户端是localhost为``True``，否则为``False`` 。应该能在代理背后工作，如果代理支持 ``http_x_forwarded_for``。
- ``request.is_https``: 如果请求使用HTTPS协议为``True``，否则为``False``。 
- ``request.body``: 一个只读文件流，其中包含HTTP请求的主体。它被自动解析得到``request.post_vars`` 然后rewind。
- 如果通过Ajax请求调用函数，``request.ajax``为真。
- ``request.cid`` 是生成Ajax请求（如有）的组件 ``id``。你可以阅读第12章中有关组件的更多内容。
- ``request.restful`` t这是一个新的和非常有用的装饰器decorator，可用于分离GET/POST/PUSH/DELETE请求来改变web2py动作的默认行为。 在第十章我们会进一步讨论。
- ``request.user_agent()`` 从客户端解析user_agent字段并以字典的形式返回信息。
这对检测移动设备是有用的。
它使用Ross Peoples创建的"gluon/contrib/user_agent_parser.py"。
要看看它做什么，尝试将下面的代码嵌入在一个视图中
``
{{=BEAUTIFY(request.user_agent())}}
``:code

- ``request.wsgi`` 是一个hook（钩子），允许你从内部动作调用第三方WSGI应用

后者包括：
- ``request.wsgi.environ``
- ``request.wsgi.start_response``
- ``request.wsgi.middleware``
在本章结尾讨论它们的用法。

作为一个例子，下面的一个典型系统中的调用

``
http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&q=2
``:code

产生下面的``request`` （请求）对象：
``request``:inxx ``env``:inxx

----------
variable | value
request.application | examples
request.controller | default
request.function | index
request.extension | html
request.view | status
request.folder | applications/examples/
request.args | ['x', 'y', 'z']
request.vars | <Storage {'p': 1, 'q': 2}>
request.get_vars | <Storage {'p': 1, 'q': 2}>
request.post_vars | <Storage {}>
request.is_local | False
request.is_https | False
request.ajax | False
request.cid | None
request.wsgi | hook
request.env.content_length | 0
request.env.content_type | ````
request.env.http_accept | text/xml,text/html;
request.env.http_accept_encoding | gzip, deflate
request.env.http_accept_language | en
request.env.http_cookie | session_id_examples=127.0.0.1.119725
request.env.http_host | 127.0.0.1:8000
request.env.http_max_forwards | 10
request.env.http_referer | http://web2py.com/
request.env.http_user_agent | Mozilla/5.0
request.env.http_via | 1.1 web2py.com
request.env.http_x_forwarded_for | 76.224.34.5
request.env.http_x_forwarded_host | web2py.com
request.env.http_x_forwarded_server | 127.0.0.1
request.env.path_info | /examples/simple_examples/status
request.env.query_string | remote_addr:127.0.0.1
request.env.request_method | GET
request.env.script_name | ````
request.env.server_name | 127.0.0.1
request.env.server_port | 8000
request.env.server_protocol | HTTP/1.1
request.env.web2py_path | /Users/mdipierro/web2py
request.env.web2py_version | Version 1.99.1
request.env.web2py_runtime_gae | (optional, defined only if GAE detected)
request.env.wsgi_errors | <open file, mode 'w' at >
request.env.wsgi_input | ````
request.env.wsgi_multiprocess | False
request.env.wsgi_multithread | True
request.env.wsgi_run_once | False
request.env.wsgi_url_scheme | http
request.env.wsgi_version | 10
--------

实际定义了哪些环境变量取决于web服务器。这里，我们假设内置的Rocket wsgi服务器。使用Apache Web服务器时，变量集没有太大的不同。

``request.env.http_*``变量从请求HTTP标报头解析

``request.env.web2py_*``变量不是从web服务器环境中解析的，而是由web2py创建的倘若你的应用需要知道web2py的位置和版本，
以及它是否运行在Google App Engine上（因为特定的优化可能是必要的）。

还要注意变量 ``request.env.wsgi_*`` 。它们对wsgi适配器是特定的

### ``response``响应对象
``response``:inxx
``response.body``:inxx
``response.cookies``:inxx
``response.download``:inxx
``response.files``:inxx
``response.flash``:inxx
``response.headers``:inxx
``response.meta``:inxx
``response.menu``:inxx
``response.postprocessing``:inxx
``response.render``:inxx
``response.status``:inxx
``response.stream``:inxx
``response.subtitle``:inxx
``response.title``:inxx
``response.toolbar``:inxx
``response.view``:inxx
``response.js``:inxx
``response.write``:inxx
``response.include_files``:inxx
``response.include_meta``:inxx
``response.optimize_css``:inxx
``response.optimize_js``:inxx

``response`` 是``Storage``类的另一个实例。它包含以下：

``response.body``: 一个 ``StringIO`` 对象，web2py向其中写入输出页面的主体。
切勿更改此变量。

``response.cookies``: 类似于``request.cookies``，但后者包含从客户端向服务器发送的cookie，前者包含由服务器发送到客户端的cookie。会话cookie自动处理。

``response.download(request, db)``: 用于实现控制器功能的方法，允许下载已上传文件。
``request.download`` 预计``request.args`` 中的最后一个参数``arg``是编码后的文件名（即，upload上传时间产生的并存储在upload字段的文件名）。它从编码文件名中提取上传字段名、表名以及原始文件名。``response.download`` 有两个可选参数： ``chunk_size``以字节为单位设置分块数据流的大小（默认为64k），
``attachments`` 确定下载的文件是否应被视为附件（默认为``True``）。
注意， ``response.download`` 是专门用于与``db`` 上传字段相关的下载文件。对于其它类型的文件下载和流媒体，使用``response.stream`` （见下文）。
另外，请注意，没有必要使用 ``response.download`` 访问上传到/static文件夹的文件—可以直接通过URL访问静态文件（例如，/app/static/files/myfile.pdf）。

``response.files``: 页面需要的CSS和JS文件的列表。
在标准"layout.html"的顶部，它们将通过包含的"web2py_ajax.html"被自动链接。要包括新的CSS和JS文件，只需将其追加到该列表中。它会处理重复。顺序是重要的。

``response.include_files()`` 生成html头标签来包含所有``response.files`` （用在"views/web2py_ajax.html"中）。

``response.flash``: 可选参数，该参数可以被包括在视图中。
通常用于通知用户发生了一件事。

``response.headers``: 一个HTTP响应标头的``dict`` 。
默认情况下，web2py设置一些标头，包括"Content-Length", "Content-Type"和 "X-Powered-By"（设置等同于web2py）。Web2py还会设置"Cache-Control", "Expires"和 "Pragma"标头以防止客户端缓存，除了静态文件请求，
会为它启用客户端缓存。web2py设置的标头可以被覆盖或删除，并且可以添加新的标头（例如，``response.headers['Cache-Control'] = 'private'``）。

``response.menu``:可选参数，可以包含在视图中，通常用来向视图传递一个导航菜单栏。它可以被MENU帮助对象呈现。

``response.meta``: 一个storage对象（类似一个字典）其中包含可选元信息如 ``response.meta.author``，``.description``， 和/或 ``.keywords``。
每一个元变量的内容被自动放置在适当的``META``标签中，这是通过"views/web2py_ajax.html"中的代码，它默认包含在"views/layout.html" 中。

``response.include_meta()``生成一个字符串其中包含所有序列化的
``response.meta`` 标头（用在"views/web2py_ajax.html"中）。

``response.postprocessing``: 这是一个函数列表，默认为空。
这些函数被用于过滤响应对象在一个动作的输出，在输出由视图呈现之前。它可以用来实现支持其它模板语言。

``response.render(view, vars)``: 用于控制器内显式调用视图的方法。
``view``是一个可选的参数，它是视图文件的名称，``vars``是传递给视图的命名值的字典。

``response.session_file``: 包含会话的文件流。

``response.session_file_name``: 将保存会话的文件的名称。

``response.session_id``: 当前会话的id。它被自动确定。切勿更改此变量。

``response.session_id_name``: 此应用会话cookie的名称。切勿更改此变量

``response.status``: 要传递给响应的HTTP状态代码整数。默认是200（OK）。

``response.stream(file, chunk_size, request=request)``: 当控制器返回它，web2py以``chunk_size``大小的块流传输文件内容返回给客户端。 ``request``参数需要在HTTP标头中使用组块的开始。如上所述，应该使用``response.download``检索通过上传字段存储的文件。``response.stream``可以使用在其它情况下，如返回一个临时文件或由控制器创建的StringIO对象。
与``response.download``不同，``response.stream``不自动设置Content-Disposition标头，所以你可能需要手工设置（例如，指定作为附件下载，并提供一个文件名）。但是，它会自动设置``Content-Type`` 标头（根据文件扩展名）。

``response.subtitle``: 可选的参数，该参数可以被包括在视图中。
它应包含页面副标题。

``response.title``: 可选的参数，该参数可以被包括在视图中。
它应包含页面标题并且应该由标头中的HTML标题TAG呈现。

``response.toolbar``:一个函数，允许你嵌入一个工具栏到调试页的表格
``{{=response.toolbar()}}``中。该工具栏显示每个查询的请求，响应，会话变量和数据库访问时间。

``response._vars``: 仅能在视图中访问此变量，而不能在动作中。
它包含由动作返回给视图的值。

``response.optimize_css``:如果可以设置为"concat,minify,inline"来连接、缩小和内联web2py包含的CSS文件。

``response.optimize_js``:如果可以设置为"concat,minify,inline"来连接、缩小和内联web2py包含的CSS文件。

``response.view``: 呈现页面的视图模板的名称。默认设置为：
``
"%s/%s.%s" % (request.controller, request.function, request.extension)
``:code

或者，如果上述文件不能定位，设置为
``
"generic.%s" % (request.extension)
``:code

改变这个变量的值来修改与一个特定动作相关联的视图文件。

``response.xmlrpc(request, methods)``: 控制器返回时，此函数通过XML-RPC``xmlrpc``:cite 公开该方法。此函数被废弃了，因为有一个更好的机制，在第10章中描述。

``response.write(text)``: 将文本写入到输出页面主体的方法。

``response.js`` 可以包含Javascript代码。
该代码将被执行，当且仅当接收到响应被web2py组件接收，在第12章中讨论。

由于``response``是一个``gluon.storage.Storage``对象，它可以用来存储你可能希望传递给该视图其它属性。虽然没有技术的限制，我们的建议是只存储要被变整体布局中的所有页面呈现的变量("layout.html")。

无论如何，我们强烈建议你坚持如下列出的变量：
``
response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*
``:code

因为这会让，用其它布局文件替换web2py附带的标准"layout.html"文件变得更容易，它们使用相同变量集。

老版本的web2py使用``response.author``而不是``response.meta.author``，其它meta属性也是相似的。

### ``session``会话对象
``session``:inxx ``session.connect``:inxx ``session.forget``:inxx ``session.secure``:inxx
``session`` 是``Storage`` 类的另一个实例。
无论存储到``session``中的是什么，例如：
``
session.myvariable = "hello"
``:code

可以在稍后的时间检索：
``
a = session.myvariable
``:code

只要代码由相同用户在同一会话中执行（倘若用户没有删除会话cookie并且会话未到期）。因为``session``是``Storage``对象，试图访问尚未设置的属性/键不会引发异常，而是返回``None`` 。

session对象有3个重要方法。其中一个是 ``forget``:
``
session.forget(response)
``:code

它告诉web2py不保存会话。这应该被用在控制器中，其动作经常被调用并且不需要跟踪用户活动。``session.forget()``防止会话文件的写入，不管它是否被修改。另外，``session.forget(response)``解锁和关闭会话文件。你很少需要调用此方法，因为会话未被改变的时候不会被保存。但是，如果页面同时进行多个Ajax请求，通过Ajax调用的动作调用``session.forget(response)``response)（假设动作不需要该会话）是一个好主意。否则，每个Ajax动作将不得不等待前一个完成（并解锁会话文件）然后再继续，这会减慢页面加载。请注意，存储在数据库中时会话不会被锁定。

另一个方法是：

``
session.secure()
``:code

它告诉web2py将会话cookie设置成一个安全的cookie。如果应用程序通过https，应该对此设置。通过设置会话cookie是安全的，服务器要求浏览器不发送会话cookie到服务器，除非通过https连接。

第三个方法``connect``:
``
session.connect(request, response, db, masterapp=None)
``:code

其中``db`` 是开放式数据库连接（如同由DAL返回的）的名称。它告诉web2py你要在数据库
而不是在文件系统中存储会话。``session.connect`` 必须跟在``db=DAL(...)``之后，但在任何其它需要会话的逻辑之前，例如，设立 ``Auth``。

web2py创建一个表：
``
db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))
``:code

并在 ``session_data`` 字段存储cPickle会话。

选项``masterapp=None``，按照默认，告诉web2py尝试检索已有会话，为名称在 ``request.application``中的应用，在运行的应用中。

如果你想让两个或多个应用共享会话，将 ``masterapp`` 设置成主应用的名称。

你可以在任何时候检查应用的状态，只需打印 ``request``， ``session`` 和``response`` 系统变量。做到这一点的方法之一是创建一个专用的行动：
``
def status():
    return dict(request=request, session=session, response=response)
``:code

#### 单独的会话

如果你在文件系统中存储会话并且很多，文件系统访问可能会成为一个瓶颈。一种解决方案如下：
``
session.connect(request, response, separate=True)
``:code

通过设置``separate=True``，web2py不会在"sessions/"文件夹中存储会话，而是在"sessions/"文件夹的子文件夹中。将自动创建子文件夹。具有相同前缀的会话将处在同一子文件夹中。同样，请注意，在任何可能需要该会话的逻辑之前，必须调用上述代码。

### ``cache``缓存对象
``cache``:inxx ``cache.ram``:inxx ``cache.disk``:inxx
``cache``是一个全局对象，在web2py执行环境中也可用。它有两个属性：
- ``cache.ram``:在主内存中的应用缓存。
- ``cache.disk``: 在磁盘上的应用缓存。
``cache``cache是可调用的，这使得它被用来作为缓存动作和视图的装饰器decorator。

下面的例子缓存RAM中的 ``time.ctime()`` 函数：
``
def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

 ``lambda: time.ctime()`` 的输出在RAM中被缓存5s。
 字符串``'time'`` 被用作缓存关键字。

T下面的例子在磁盘上缓存 ``time.ctime()`` 函数：
``
def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

 ``lambda: time.ctime()`` 的输出被缓存在磁盘上（使用shelve模块）持续5s。

注意， ``cache.ram`` 和 ``cache.disk``的第2个参数必须是函数或可调用的对象。
如果你想缓存现有对象而不是函数的输出，你只需通过一个lambda函数将它返回：
``
cache.ram('myobject', lambda: myobject, time_expire=60*60*24)
``:code

下一个例子缓存 ``time.ctime()`` 函数到RAM和磁盘：
``
def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda:time.ctime()``的输出被缓存在磁盘上（使用shelve模型）之后缓存在RAM，持续5秒。web2py现在RAM中寻找如果没有再到磁盘上寻找。如果它不在RAM中也不在
磁盘上，``lambda:time.ctime()``被执行并更新缓存。这种技术在多进程环境中是非常有用的。两次不必是相同的。

下面的例子是在RAM中缓存控制器函数的输出（但不是视图）：

``cache controller``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))
``:code

 ``cache_controller_in_ram``返回的字典被缓存在RAM中，持续5秒。注意，数据库选择的结果必须先序列化之后在缓存。更好的方法是直接使用 ``select`` 方法的 ``cache`` 参数缓存数据库选择。

下面的例子是在磁盘上缓存控制器函数的输出（但不是视图）：
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload',
                              _href=request.url))
``:code

``cache_controller_on_disk``返回的字典缓存在磁盘上，持续5秒。请记住，web2py不能缓存包含un-pickle对象的字典。

也可以缓存视图。关键是要在控制器函数中呈现视图，使控制器返回一个字符串。这是通过返回``response.render(d)``完成的，其中``d``是我们打算传递给视图的字典。下面的例子在RAM中缓存控制器函数的输出（包括呈现的视图）：

``cache view``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)
``:code
``response.render(d)``作为一个字符串返回呈现的视图，现在它已经被缓存了5秒。这是最好也最快的缓存方法。

注意，``time_expire``用来比较当前时间和所请求对象在cache中上一次保存的时间。它不影响未来的请求。这允许在请求对象时动态设置``time_expire``，而不是在保存对象时固定它。例如：
``
message = cache.ram('message', lambda: 'Hello', time_expire=5)
``:code

现在，假设如下调用在上述调用10秒之后出现：
``
message = cache.ram('message', lambda: 'Goodbye', time_expire=20)
``:code

因为在第2个调用中``time_expire``设置成20秒并且距消息第一次被保存只过去了10秒，值"Hello"将从缓存中恢复，它不会被更新成"Goodbye"。第一个调用中5秒的``time_expire`` 不会影响第2个调用。

设置``time_expire=0``（或者一个负数）强制更新缓存项目（因为距上次保存所经过的时间总是>0），设置``time_expire=None``强制恢复缓存值，不管距上次保存所经过的时间（如果 ``time_expire``始终是``None``，缓存项目将有效地永不过期）。

如下，你可以清除一个或多个缓存变量
``cache clear``:inxx

``
cache.ram.clear(regex='...')
``:code

这里``regex``是一个正则表达匹配你想从缓存中移除的所有键。如下，你还可以清除单个项目：
``
cache.ram(key, None)
``:code

这里 ``key`` 是缓存项目的键。
也可以定义其它缓存机制例如memcache。Memcache通过``gluon.contrib.memcache`` 可用并会在第14章详细讨论。

------
缓存时要小心，缓存通常是在应用层而不是用户层。如果你需要，例如，缓存特定用户内容，选择一个包含用户id的键。
------


### ``URL``统一资源定位器
``URL``:inxx
``URL`` 函数是web2py中最重要的函数之一。它为动作和静态文件生成内部URL路径。

这里是一个例子：

``
URL('f')
``:code

它被映射成

``
/[application]/[controller]/f
``:code

注意，``URL``函数的输出取决于当前应用的名称，调用控制器，以及其它参数。web2py支持URL映射及URL逆映射。URL映射允许你重定义外部URL的格式。
如果你使用``URL``函数来生成所有的内部URL，对URL映射的增加或改变将防止破坏web2py应用中的链接。

你可以传递附加参数到``URL``函数，即，URL路径中的附加项（args）和URL 查询变量（vars）：

``
URL('f', args=['x', 'y'], vars=dict(z='t'))
``:code

被映射成

``
/[application]/[controller]/f/x/y?z=t
``:code

``args``属性被自动解析、解码并最终由web2py存储在``request.args``中。类似的，``vars``被解析、解码之后存储在``request.vars``中，并且vars提供基本机制，web2py通过该机制与客户端浏览器交换信息。

如果args仅包含一个变量，没有必要在列表中传递它。

你还可以用``URL`` 生成到其它控制器和其它应用中的动作的URL：

``
URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))
``:code

被映射成：

``
/a/c/f/x/y?z=t
``

另外，也可以使用命名参数指定应用，控制器和函数：
``
URL(a='a', c='c', f='f')
``:code

如果应用名a找不到，假定为当前应用。

``
URL('c', 'f')
``:code

如果控制器名找不到，假定是当前的。

``
URL('f')
``:code

也可以传递函数本身而不是传递控制器函数的名称。

``
URL(f)
``:code

基于上述原因，你应该总是使用的``URL``函数来为你的应用程序生成静态文件的URL 。静态文件存储在应用的``static``子文件夹中（这就是使用管理界面上传后它们去的地方）。web2py提供一个虚拟的'static'控制器，它的工作就是从``static`` 子文件夹中检索文件，确定它们的内容类型，并将文件流传输到客户端。下面的例子为静态文件"image.png"生成URL：

``
URL('static', 'image.png')
``:code

被映射成

``
/[application]/static/image.png
``:code

如果静态文件位于``static``文件夹的子文件夹中，作为文件名的一部分，你可以包含子文件夹。例如，为了生成：

``
/[application]/static/images/icons/arrow.png
``

你可以使用：

``
URL('static', 'images/icons/arrow.png')
``:code


您不需要编码/转义的``args``和``vars``参数；这将为你自动完成。

按照默认，对应于当前请求的扩展（可以在``request.extension``中找到）被追加到函数，除非request.extension是默认的html。这可以重写，通过明确地包含一个扩展，作为函数名``URL(f='name.ext')`` 的一部分或带有扩展参数：
``
URL(..., extension='css')
``:code

可以明确地抑制当前扩展：
``
URL(..., extension=False)
``:code

#### 绝对url

按照默认， ``URL`` 生成相对的URL。但是，你也可以生成绝对URL通过指定``scheme`` 和 ``host`` 参数（这是有用的，例如，在email中插入URL时）：

``
URL(..., scheme='http', host='www.mysite.com')
``:code

你可以自动包含当前请求的方案和主机只需将参数设为``True``。

``
URL(..., scheme=True, host=True)
``:code

如果需要的话，``URL`` 函数还接受一个``port`` 参数来指定服务器端口。

#### 数字签名的url
``digitally signed URL``:inxx

当生成URL，你可以选择数字签名它。这将追加能被服务器确认的 ``_signature`` GET变量。这有两种实现方法。

你可以将以下参数传递给URL函数：
- ``hmac_key``: 签署名URL的密钥（一个字符串）
- ``salt``: 一个可选字符串在签署之前salt加密数据
- ``hash_vars``: 来自URL查询字符串的变量名可选列表（即，GET变量）要包含在签名中。也可以将它设置成``True``，以包含全部变量；或``False``，以不包含任何变
量。

下面是一个用法的例子：

``
KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # do something
    return locals()
``:code

这使得只能通过数字签名的URL才能访问action``two``。
数字签名URL看起来是这样的：
``
'/welcome/default/two?a=123&_signature=4981bc70e13866bb60e52a09073560ae822224e9'
``

注意，数字签名通过``URL.verify`` 函数验证。``URL.verify``还需要上面描述的 ``hmac_key``，``salt``，和``hash_vars``参数，并且当数字签名被创建以验证URL时，它们的值必须匹配传递给 ``URL`` 函数的值。

第二个更为复杂但更常见的使用数字签名的例子是与Auth相关联。最好通过例子来解释：

``
@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # do something
    return locals()
``:code

在这种情况下``hmac_key``自动生成并在该会话中共享。这使得行动``two``代表行动``one``任何访问控制。如果该链接是产生并签名，它是有效的；否则它并不不是。如果该链接是被另一个用户盗取，链接将是无效的。

这是很好的做法，总是数字签名Ajax回调。如果你使用web2py负载功能 ``LOAD`` 函数，它有一个 ``user_signature`` 参数也可用于这一目的。

``
{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}
``

### ``HTTP`` 和重定向``redirect``
``HTTP``:inxx ``redirect``:inxx

web2py只定义了一个新异常叫做``HTTP``。该异常可以使用如下命令在任何一个模型、控制器或视图中引发：

``
raise HTTP(400, "my message")
``:code

它导致控制流从用户代码跳出，返回到web2py，并返回HTTP响应如下：
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message
``:code

第一个``HTTP``参数是HTTP的状态代码。第二个参数是字符串，返回响应的主体。附加可选命名的参数用来构建响应HTTP的报头。
例如：
``
raise HTTP(400, 'my message', test='hello')
``:code

生成：
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message
``:code

如果你不想提交开放数据库的事务，在引发异常前回滚。任何异常非HTTP导致web2py回滚到公开数据库事务，日志错误记录，发布票据给访问者，返回到标准错误页面。

这意味着只有``HTTP``能用于交叉页控制流。其它异常必须被应用捕获，否者会被web2py发
票据。



命令：
``
redirect('http://www.web2py.com')
``:code

是下面的快捷方式：
``
raise HTTP(303,
           'You are being redirected <a href="%s">here</a>' % location,
           Location='http://www.web2py.com')
``:code

命名的``HTTP`` 初始对象方法的参数直接翻译为HTTP报头指令，这种情况，重定向目标位置。 ``redirect`` 用可选的第二参数，是重定向的HTTP状态代码（默认303）。暂时
重定向修改该数字为307或永久重定向修改为301。

最常见使用重定向的方法是重定向到同个应用的其它页面或（可选）传递参数：

``
redirect(URL('index', args=(1,2,3), vars=dict(a='b')))
``:code

### ``T`` 和 国际化
``T``:inxx ``internationalization``:inxx

对象 ``T`` 是语言翻译对象。它构成web2py类 ``gluon.language.translator`` 单个全局实例。
所有字符串常量（仅字符串常量）用``T``标识，例如：
``
a = T("hello world")
``:code

用``T``标注的字符串被web2py识别成需要语言翻译，当执行代码（模型，控制器，或视图中）时它们将被翻译。如果需要翻译的字符串不是常量而是变量，运行时它将被加入翻译文件（除非在GAE上）此后被翻译。

``T`` 对象还能包含插值变量并支持多重等价语法：
``
a = T("hello %s", ('Tim',))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim',)
a = T("hello %(name)s") % dict(name='Tim')
``:code

后者的语法建议因为它使翻译更容易。第一个字符串是根据请求的语言翻译文件，名称``name`` 变量替换独立于语言。

连接翻译的字符串和普通字符串的翻译是可能的：
``
T("blah ") + name + T(" blah")   # invalid!
``:code

但相反的，没有：

``
name + T(" blah")   # invalid!
``:code

下面的代码也可以，通常最好：

``
T("blah %(name)s blah", dict(name='Tim'))
``:code

或替代语法
``
T("blah %(name)s blah") % dict(name='Tim')
``:code

在这两种情况下的翻译之前发生的变量名是取代在“%（名字）的“槽。
下面的不应该用：
``
T("blah %(name)s blah" % dict(name='Tim'))
``:code

因为翻译后发生的替代。

要求的语言，是由“可”字段中的头，但这一选择可以覆盖由编程请求一个特定的文件，例如：
``
T.force('it-it')
``:code

读取"languages/it-it.py"语言文件。语言文件可以通过管理界面创建和编辑。

你也可以强制用per-string语言：

``
T("Hello World", language="it-it")
``:code

你可以通过如下命令完全关闭翻译

``
T.force(None)
``:code

通常，当视图呈现时字符串翻译懒洋洋地被评估；因此，翻译对象 ``force`` 方法不该在视图中调用。

能禁用lazy评估通过
``
T.lazy = False
``:code

这样，字符串立即被 ``T`` 运算符基于当前接受或强制的语言翻译。

也能对个别字符串禁用lazy评估：

``
T("Hello World", lazy=False)
``:code

一个常见的问题是以下。最初的应用是在英国。假设有一个翻译文件（例如意大利语，"itit.py"）和客户端声明它接受英文（中文）和意大利（资讯科技）。以下意外情况发生：web2py不知道默认是写在英语（中文）。因此，它喜欢什么都翻译成意大利语（资讯科技）因为它只发现意大利语翻译文件。如果它没有找到“那里。快乐”的文件，它将使用默认语言（英文）。

有解决这个问题：创建一个语言翻译为英文，这将是多余的和不必要的，或更好，告诉web2py语言应该使用默认语言的字符串（字符串编码到应用程序）。这是可以做到的：
``
T.set_current_languages('en', 'en-en')
``:code

它存储在``T.current_languages``语言列表，不需要翻译和部队重新加载的语言文件。

注意，“这”和“那”是不同语言的角度web2py。支持他们两个，将需要一个翻译文件，
总是小写。这同样适用于所有其他语言。

目前接受的语言是储存在
``
T.accepted_language
``:code

注意T(...)不仅翻译字符串也能翻译变量：
``
>>> a="test"
>>> print T(a)
``:code

这种情况，词“test”翻译了，但如果没有找到并且如果文件系统是可写的，它将添加它到在语言文件中要翻译到的词列表。

### ''Cookies''
``cookies``:inxx

web2py使用Python cookie模块处理cookie。

来自浏览器的cookie在``request.cookies`` 中，由服务器发送的cookie在 ``response.cookies``中。

你可以如下设置cookie：
``
response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'
``:code

第二行告诉浏览器保留cookie 24小时。
第三行告诉浏览器发回cookie到当前域名的任何应用（URL路径）。
注意，如果你不给cookie指定路径，浏览器会假定所请求的URL路径，因此当相同的URL路径路径被请求，cookie只被返回到服务器。

cookie 可以用下面的语句设置为安全：
``
response.cookies['mycookie']['secure'] = True
``:code

这告诉浏览器值只通过HTTPS发回cookie而不是通过HTTP。

cookie能被如下得到：
``
if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value
``:code

除非会话被禁用，web2py，在底层，设置下列cookie并使用它处理会话：
``
response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"
``:code

注意， 如果单个应用包含多个子域名， 而且你想在哪些子域名间（ 例如sub1.yourdomain.com,sub2.yourdomain.com等）共享会话，你必须显式设置会话cookie域名如下：
``
if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"
``:code

上述非常有用，如果，例如，你想允许用户在各子域名间保持登录。


### 应用程序 **init**
``init``:inxx

当你部署web2py时，你会希望设置一个默认应用，即，URL中存在空路径时启动的应用，如同在：
``
http://127.0.0.1:8000
``:code

按照默认，遇到空路径时，web2py寻找名为**init**的应用。如果没有init应用，它寻找名为 **welcome**的应用。

``default_application``:inxx
通过设置routes.py中的``default_application``，默认应用的名称可以从**init**改成其它名称。
``
default_application = "myapp"
``:code

注意： ``default_application`` 最早出现于web2py版本1.83。

以下是四种设置默认应用的方法：
- 将默认应用称为"init"
- 在routes.py中将``default_application`` 设为你的应用名称
- 创建一个从"applications/init"到你的应用文件夹的符号链接
- 使用下一部分讨论的URL重写

### URL 重写
``url rewrite``:inxx
``routes_in``:inxx
``routes_out``:inxx

 web2py有能力在调用控制器action（URL映射）之前重写进来的请求的URL路径，相反的，web2py可以重写由``URL``函数生成的URL路径（反URL映射）。这么做的一个原因是为了处理URL的遗留数据，另一个是为了简化路径使之变短。

web2py包含两个不同的URL重写系统：简单易用的parameter-based系统适用于大多数使用场合，和灵活的pattern-based 系统适用于更复杂的场合。为了简化URL 重写规则，在"web2py"文件夹中创建一个新文件称作``routes.py``（``routes.py``的内容取决于你选用两种重写系统中的哪一种，正如下面两部分介绍的）。两个系统不能混用。

-------
注意，如果你编辑routes.py，你必须重载它。可以用两种方法完成：通过重启web服务器或通过点击admin中的路径重载按钮。如果路径中有错误，它们不会重载。
-------

#### 基于参数的系统

基于参数（参数的）路由器提供到若干“canned”重写URL的便捷访问方法。它的能力包括：

* 忽略从外部可见URL的默认应用、控制器和函数名（那些由URL（）函数创建）

* 将域（和/或端口）映射到应用或控制器

* 在URL中嵌入语言选择器

* 移除进来的URL中的固定前缀并将它加入出去的URL中。

* 将根文件如/robots.txt映射到应用静态目录

参数路由还提供更灵活的输入URL验证。

假设你编写了一个叫做``myapp``的应用并希望将它设为默认，这样应用名就不是用户看到的URL中的有一部分了。你的默认控制器还是``default``，你也想从用户可见的URL中删除其名字。下面是写在``routes.py``的代码：
``
routers = dict(
  BASE  = dict(default_application='myapp'),
)
``:code

就是这些了。参数路由足够聪明，知道如何处理这样的URL:
``
http://domain.com/myapp/default/myapp
``:code
或者
``
http://domain.com/myapp/myapp/index
``:code
这里普通的缩减会含义模糊。如果你有两个应用， ``myapp`` 和 ``myapp2``, myapp2，你会得到相同的效果此外安全的时候（几乎所有时候），``myapp2``的默认控制器会被从URL中抽取出来。

下面是另一种情况：假设你想支持基于URL的语言，这里你的URL看起来如下：
``
http://myapp/en/some/path
``:code
或（重写）
``
http://en/some/path
``:code

具体方法如下：
``
routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)
``:code

传入的URL是这样的：
``
http:/domain.com/it/some/path
``:code
将被路由到``/myapp/some/path``，并且request.uri_language将被设置为'it'，这样你就可以强制翻译。你也可以使用特定语言的静态文件。

``
http://domain.com/it/static/filename
``:code
将被映射到：
``
applications/myapp/static/it/filename
``:code
如果该文件存在。如果不存在，那么URL如下：
``
http://domain.com/it/static/base.css
``:code
仍然会映射到：
``
applications/myapp/static/base.css
``:code
（因为没有``static/it/base.css``）。

所以，你现在可以有特定语言的静态文件，包括图片，如果你需要的话。还支持域映射：
``
routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)
``:code
完成你所期望的。

``
routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)
``:code
映射 ``http://domain.com`` 访问到命名为``insecure``,的控制器，而``HTTPS``访问映射到``secure``控制器。或者，你也可以将不同的端口映射到不同的应用，以明显的方式。

欲了解更多信息，请咨询标准web2py 发行版基础文件夹中提供的的基础文件夹 [[``router.example.py`` http://code.google.com/p/web2py/source/browse/router.example.py]] 文件。

注：基于参数的系统第一次出现在web2py版本1.92.1中。

#### 基于模式的系统

尽管刚刚描述的parameter-based系统对于绝大多数应用情况已经足够了，替代的patternbased系统为更复杂的情况提供一些额外的灵活性。为了使用pattern-based系统，你不用将路由定义为路由参数字典，而是定义元组``routes_in``和``routes_out``的两个列表（或元组）。每个元组包含两个元素：将要替换的模式和替换它的字符串。例如：
``
routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)
``:code

使用这些路由，如下URL：
``
http://127.0.0.1:8000/testme
``:code

被映射到：
``
http://127.0.0.1:8000/examples/default/index
``:code

对于访问者，所有到该页面URL的链接看起来如 ``/testme``.

该模式与Python正则表达式有相同的语法。例如：
``
  ('.*\.php', '/init/default/index'),
``:code

将所有以".php"结尾的URL 映射到索引页。

有时你想摆脱来自应用的URL前缀，因为你计划只公开一个应用。这可以如下实现：
``
routes_in = (
  ('/(?P<any>.*)', '/init/\g<any>'),
)
routes_out = (
  ('/init/(?P<any>.*)', '/\g<any>'),
)
``:code

还有另一种语法，可以与上述正则表达式符号混合使用。它包括使用``$name`` 取代 ``(?P<name>\w+)`` 或``\g<name>``。 例如：
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)
``:code

也消除了所有URL 中的"/example"应用前缀。


使用``$name`` 符号，你可以自动映射``routes_in`` 到``routes_out``， 只要你不使用任何正则表达式。
例如：
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]
``:code

如果有多个路由，第一个匹配URL的被执行。如果没有模式匹配，路径保持不变。

您可以使用 ``$anything`` g匹配anything(``.*``) ，直到该行结束。

这里是一个最小的“routes.py”用于处理图标和机器人请求：

``favicon``:inxx ``robots``:inxx
``
routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()
``:code

下面是一个更复杂的例子，不使用不必要的前缀暴露了一个单一的应用“myapp”，但也暴露了 **admin**， **appadmin** 和静态：

``
routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]
``:code

路由的一般语法比我们迄今所看到的简单例子要复杂得多。这里是一个更普遍的有代表性的例子：
``
routes_in = (
 ('140\.191\.\d+\.\d+:https://www.web2py.com:POST /(?P<any>.*)\.php',
  '/test/default/index?vars=\g<any>'),
)
``:code

它把来自匹配正则表达式的远程IP的 ``https`` ``POST`` 请求映射到主机``www.web2py.com`` 
``
'140\.191\.\d+\.\d+'
``:code

请求一个匹配正则表达式的页面
``
'/(?P<any>.*)\.php'
``:code

到
``
'/test/default/index?vars=\g<any>'
``:code

这里``\g<any>``被匹配正则表达式取代。

普通的语法是
``
'[remote address]:[protocol]://[host]:[method] [path]'
``:code

整个表达被作为正则表达式匹配，因此"."应始终被转义并且根据Python 正则表达式语法可以使用``(?P<...>...)``捕获任何匹配的子表达式。

这允许基于客户端的IP地址或域名，基于请求的类型、方法和路径的重新路由请求。它也允许web2py将不同的虚拟主机映射到不同的应用。任何匹配的子表达式可以用来建立目标URL，最后，作为GET变量传递。

所有主要Web服务器，如Apache和lighttpd，也有能力重写URL。在生产环境中，这可以是取代``routes.py``的一种选择。无论你决定做什么，我们强烈建议您不要硬编码应用内部的URL并使用的URL函数来生成它们。如果路由改变，这将使您的应用可移植性更好。

##### Application-Specific URL rewrite
``routes_app``:inxx
在使用基于模式的系统时，在位于应用基础文件夹的特定于应用的routes.py文件中，应用可以设置自己的路径。通过设置``routes_app``启动此功能来根据传入的的URL决定选择的应用名称。
当这发生时，特定于应用的routes.py被用来取代基础的routes.py。

``routes_app``的格式与``routes_in``相同，不同的是替换模式是简单的应用名称。如果将``routes_app``应用于传入的URL得不到应用名称，或产生的特定于应用的routes.py没有找到，该基础routes.py照常使用。

注：``routes_app`` 第一次出现在web2py版本1.83中。

##### 默认应用，控制器，和函数  
``default_application``:inxx
``default_controller``:inxx
``default_function``:inxx

使用基于模式的系统时，默认应用、控制器和函数的名称可以通过在routes.py中设置适当的值分别由 **init**， **default** 和 **index** 改为其它名称。
``
default_application = "myapp"
default_controller = "admin"
default_function = "start"
``:code

注：这些项目最早出现在web2py版本1.83中。

### 出错路由 
``routes_onerror``:inxx

如果服务器上有错误，您还可以使用``routes.py``重新将请求路由到特殊动作。在全局范围内，您可以为每个应用、每个错误代码或者为每个应用和错误代码指定这个映射。下面是一个例子：
``
routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]
``:code

对于每一个元组，
第一个字符串与"[app name]/[error code]" 相匹配。如果找到匹配，失败的请求被重新路由到匹配元组的第二个字符串中的URL。如果错误处理URL不是静态文件，下面的GET变量将被传递到错误动作：
- ``code``: tHTTP状态代码（例如，404,500）
- ``ticket``: 形式为"[app name]/[ticket number]"（或"None"如果没有票据）
- ``requested_uri``:等同于``request.env.request_uri``
- ``request_url``: 等同于``request.url``

错误处理动作可以通过``request.vars`` 访问这些变量，这些变量还能用于生成错误响应。尤其是，错误动作返回原始的HTTP错误代码而不是默认的200（OK）状态码是一个好主意。这可以通过设置``response.status = request.vars.code``来完成。也有可能让错误动作（或队列）发送电子邮件给管理员，包括到 ``admin``中票据的链接。

不匹配的错误显示默认错误页面。默认错误页面也可以在这里定制（参见web2py根文件夹
中的``router.example.py``和``routes.example.py`` ）:
``
error_message = '<html><body><h1>%s</h1></body></html>'
error_message_ticket = '''<html><body><h1>Internal error</h1>
     Ticket issued: <a href="/admin/default/ticket/%(ticket)s"
     target="_blank">%(ticket)s</a></body></html>'''
``:code

请求无效应用或函数时，第一个变量包含错误消息。票据发出时，第二个变量包含错误消息。

-------
``routes_onerror`` 可用于两种路由机制。
-------

### 后台运行任务

在web2py中，每一个HTTP请求在它自己的线程中被服务。线程被回收以提高效率并且线程由web服务器管理。出于安全考虑，Web服务器对每个请求设置超时时间。这意味着，动作不应该执行耗时太长的任务，不应该创建新的线程，不应该派生进程（可以这么做但不推荐）。

执行耗时的任务的正确方法是后台执行。没有一种完成它的方法，但在这里我们将介绍web2py内置的三种机制：**cron**，**homemade task queues**和**scheduler**。

我们所说的 **cron** 是web2py中的一个不专属于UNIX cron机制的功能。web2py cron也适用于windows。

web2py cron是应该选择的方法，    
个调用之间的时间间隔比较相对较短。每个任务都在自己的进程中运行，可以同时运行多个任务，但你不能控制有多少任务运行。如果不小心一个任务与自身重叠，它可能会导致数据库锁定和内存使用量激增。

web2py的调度采用不同的方法。正在运行的进程数目是固定的，并且它们可以在不同的机器上运行。每个进程被称为一个工人。每个工人取一个可用任务并在预定时间之后尽快执行该任务，但不一定是在确切的时间。正在运行的进程数不能多于预定任务数，这样不会有内存使用激增。调度程序的任务可以被定义在模型中并且存储在数据库中。 web2py的调度没有实现分布式队列，因为它假定分配任务的时间与运行任务的时间相比是微不足道的。工人从数据库中取任务。

在某些情况下，自制任务队列可以是web2py调度的一个简单替代。

#### ''Cron''
``cron``:inxx

web2py的cron以与平台无关的方式为应用提供在预设时间执行任务的能力。
对于每个应用，cron功能由crontab文件定义：


``
app/cron/crontab
``

这遵循ref. ``cron``:cite 中定义的语法（有一些特定于web2py的扩展）。

这意味着，每个应用可以有一个单独的cron配置并且可以在web2py中改变cron配置而不影响主机操作系统本身。

这里是一个例子：
``
0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py
``:code

这个例子中的最后两行使用扩展规范cron语法以提供额外的web2py功能。

-------
文件"applications/admin/cron/expire_sessions.py"实际存在并附带admin应用。它检查过期会话并删除它们。"applications/admin/cron/crontab"按小时执行此任务。
-------

If the task/script is prefixed with an asterisk (``*``) and ends with ``.py``, it will be executed in the web2py environment. This means you will have all the controllers and models at your disposal. If you use two asterisks (``**``), the ``MODEL``s will not be executed. This is the recommended way of calling, as it has less overhead and avoids potential locking problems.

请注意，在web2py环境中执行的脚本/函数在函数结尾需要一个手动的 ``db.commit()`` 否则交易将被还原。

 在shell模式下，web2py不会生成票据或有意义的回溯，cron在该模式下运行，所以在你将其设为cron任务之前一定要确保你的web2py代码运行没有错误，因为从cron运行时你将不能看到那些错误。此外，要小心你如何使用模型：虽然执行发生在一个单独的进程中，为了避免页面等待可能锁存数据库的cron任务，必须考虑数据库锁存。如果在cron任务中你不需要使用数据库，使用``**`` 语法。

你也可以调用控制器函数，那样的情况不需要指定路径。控制器和函数将是调用应用的。特别在意上面列出的注意事项。示例：
``
*/30  *  *  *  *  root *mycontroller/myfunction
``:code

如果你在crontab文件中的第一个字段指定``@reboot``，给定的任务将只在web2py启动时执行一次。你可以使用此功能，如果你要在web2py启动时预缓存，检查，或者初始化应用数据。需要注意cron任务是与应用并行执行的---如果直到cron任务完成后，应用没有准备好服务请求，你应该执行检查以反映这一点。示例： 
``
@reboot  *  *  *  *  root *mycontroller/myfunction
``:code

根据你如何调用web2py，web2py cron有四种操作模式。
- ''soft cron'': 所有执行模式下都可用
- ''hard cron'':如果使用内置web服务器（直接使用或通过Apache mod_proxy）则可用
- ''external cron'': 如果你能访问系统自己的cron服务则可用
- 无cron

如果你使用的是内置web 服务器，默认是hard  cron， ；在所有其他情况下，默认是soft cron。 如果你使用的是CGI，FastCGI或WSGI，soft cron是默认方法（但要注意，web2py
提供的标准``wsgihandler.py``文件中默认不``enabled``soft cron）。 

你的任务在crontab指定的时间之后第一次调用（页面加载）web2py时被执行；但要在处理页面之后，所以用户不会观察到延时。显然，关于任务具体什么时候执行存在不确定性，取决于站点接收的流量。还有，如果web服务器有页面加载时间设置cron任务可能被打断。
如果这些限制不能接受，参见external cron。Soft cron是一个合理的不得已而为之，但如果你的web服务器允许其它cron方法，应优先选用它们。

如果你使用内置web 服务器（直接使用或通过Apache mod_proxy），hard cron 是默认。Hard cron在并行线程中执行，所以不像soft cron， 关于运行时间或执行时间精度没有限制。

在任何情况下，外部cron不是默认，但需要你能访问系统cron设施。它运行在平行进程中，所以soft cron 的任何限制都不适用。 在WSGI或FastCGI下，这是推荐的使用cron的方式。

添加到系统crontab文件（通常是/ etc / crontab）中的代码行的例子：
``
0-59/1 * * * * web2py cd /var/www/web2py/ && python web2py.py -J -C -D 1 >> /tmp/cron.output 2>&1
``:code

如果你运行的是外部cron，确保添加-N命令行参数到你的web2py启动脚本或配置，这样cron的多种类型没有冲突。此外，对于外部``cron``，一定要加上``-J``
（或``--cronjob``,这是相同的）如上文所述，这样web2py知道任务是由cron执行。 web2py使用soft cron和hard``cron``对此内部设置。

在一个特定进程中，在你不需要任何cron功能的情况下，你可以使用-N命令行参数来禁用它。请注意，这可能会禁用一些维护任务（如自动清理会话文件夹）。此功能的最常见的用途是，当你：
- 已经设置了系统触发的外部cron（最常见的是使用WSGI设置）。
- 要调试你的应用，而不需要cron干预动作或输出。

#### 自制任务队列

虽然以规定的时间间隔运行任务cron是有用的，但它并不总是运行后台任务的最佳解决方案。为了这个目的，web2py提供运行任何Python脚本的能力，就像它是在一个控制器中。
``
python web2py.py -S app -M -N -R applications/app/private/myscript.py -A a b c
``:code

这里
``-S app``告诉web2py作为"app"运行"myscript.py"， ``-M``告诉web2py执行模型，``-N`` 告诉web2py 不运行cron，并且``-A a b c`` 传递可选命令行参数``sys.args=['a','b','c']`` 到 "myscript.py"。

这种类型的后台进程不应该通过cron执行（也许除非是为了cron @reboot）， 因为你需要确保同一时间运行的实例不超过一个。使用cron可能出现一个进程在cron 迭代1开始，cron迭代2还未完成，所以cron再次，再次，再次启动它-因此堵塞邮件服务器。

在第8章中，我们将提供一个如何使用上面的方法来发送电子邮件的例子。
#### 调度程序（实验性的）

web2py的调度非常类似于在上一小节中介绍的任务队列，有一些不同：
- 它提供一个标准机制，用于创建和调度任务。
- 没有单个后台进程但有一组工作进程。
- 工作节点的任务可以被监控因为它们的状态，还有任务的状态，存储在数据库中。
- 它工作不需要web2py但没有记录在这里。

调度不使用cron，尽管可以使用@reboot启动工作节点。

在调度中，任务就是一个定义在模型中（或者在模块中并由模型导入）的函数。
例如：

``
def task_add(a,b):
    return a+b
``:code

任务总是在控制器看到的相同环境中被调用，因此控制器可以看到定义在模型中的所有全局变量，包括数据库连接（``db``）。任务与控制器动作不同因为它们不与HTTP请求关联因此不存在``request.env``。

一旦任务定义，你需要通过将下面的代码添加到你的模型启用调度程序：

``
myscheduler = Scheduler(db, dict(task_add=task_add))
``

``Scheduler``类的第一个参数必须是调度要使用的与工人沟通的数据库。这可能是应用程序的db或其它专用``db``，也许是一个由多个应用程序共享``db``。调度程序将创建需要的表。第二个参数是一个``key:value`` 对Python字典，其中``key`` 是你公开任务要使用的名称，``value``是定义任务的函数的实际名称。   

一旦任务被定义并且``Scheduler``被实例化，所有需要做的就是启动工人：

``
python web2py.py -K myapp
``

``-K``选项将启动一个工人。``-K``选项的参数是以逗号分隔的应用名称的列表。这是工人将服务的应用。我们可以启动许多工人。

现在我们的基础设施到位：明确了任务，告诉了调度，启动了工作者（S）。剩下的就是实际安排任务：

可以编程方式或通过appadmin 预定任务。事实上，任务预定可以简单地通过在表"scheduler_task"中添加一个条目来完成，你可以通过访问appadmin该表：

``
http://127.0.0.1:8000/scheduler/appadmin/insert/db/scheduler_task
``

此表中字段的含义是显而易见的。"args"和"vars"字段是要以JSON格式传递给任务的值。在上面的"task_add"例子中，"args"和"vars"的例子可以是：

``
args = [3, 4]
vars = {}
``

或

``
args = []
vars = {'a':3, 'b':4}
``

任务可以处在下列状态之一：

``
QUEUED, RUNNING, COMPLETED, FAILED, TIMEOUT
``

一旦任务存在（“scheduler_task”表中有记录），被``QUEUED``，并已准备好（满足所有在记录中指定的条件），它可以被工人取走。只要有可用的工人，它取走首先准备好的预定运行的任务。工人在另一个表"scheduler_run"（也创造由调度）中创造一个条目。

表"scheduler_run"保存所有正在运行的任务的状态。每个记录引用一个被工人取走的任务。
一个任务可以有多个运行。例如，一个预计一个小时重复10次的任务可能会有10次运行（除非其中一个出现故障或时间超过1小时）。

可能的运行状态是：

``
RUNNING, COMPLETED, FAILED, TIMEOUT
``

当``QUEUED``的任务被取走，它成为一个``RUNNING``任务并且它的运行状态也是``RUNNING``。
如果运行完成，没有异常抛出，也没有任务超时，该运行标记为``COMPLETED``并且该任务标记为``QUEUED``或``COMPLETED``取决于稍后的时间是否会再次运行它。任务的输出是在JSON中序列化并存储在运行记录中。

当``RUNNING`` 的任务抛出一个异常，运行标记为 ``FAILED`` 并且任务被标记为``FAILED``。回溯被存储在运行记录中。

同样，当运行超时，它被停止并标记为``TIMEOUT``，任务标记为``TIMEOUT``。

在任何情况下，stdout被捕获并且被记录到运行记录。

使用appadmin，可以检查所有 ``RUNNING`` 的任务， ``COMPLETED``任务的输出，``FAILED`` 任务的错误等。

调度程序还创建了一个表称为“scheduler_worker”，其中存储工人的心跳和他们的状态。工人可能的状态是：

``
ACTIVE, INACTIVE, DISABLED
``

通过使用appadmin改变其状态，你可以禁用工人。

通过appadmin能完成的都能通过插入和更新这些表中的记录以编程的方式完成。

无论如何，不应该更新与``RUNNING``任务相关的记录因为这可能会造成不可预期的行为。最好的做法是使用 "insert" 为任务排队。例如：

``
db.scheduler_task.insert(
    status='QUEUED',
    application_name='myapp',
    task_name='my first task',
    function_name='task_add',
    args='[]',
    vars="{'a':3,'b':4}",
    enabled=True,
    start_time = request.now,
    stop_time = request.now+datetime.timedelta(days=1),
    repeats = 10, # run 10 times
    period = 3600, # every 1h
    timeout = 60, # should take less than 60 seconds
    )
``:code

请注意字段“times_run”，“last_run_time”和“assigned_worker_name”没有在计划的时间提供，但会由工人自动填充。

你还可以检索已完成任务的输出：

``
completed_runs = db(db.scheduler_run.status='COMPLETED').select()
``:code

------
调度是实验性的，因为它需要更广泛的测试还因为随着越来越多的功能被添加表的结构可能发生变化。
------

- 我们建议有一个单独的模型文件来确定任务和实例化``Scheduler`` （在任务被定义之后）。 
- 我们建议每个应用至少使用一名工人，让你有更多的控制权，虽然这不是绝对必要的。
- 如果你的任务是定义在一个模块（而不是一个模型）中，你可能需要重新启动工人。

### 第三方模块
``import``:inxx

web2py是用Python编写的，所以它可以导入和使用任何Python模块，包括第三方模块。它只是需要能够找到它们。如同任何Python 应用，模块可以安装在官方Python 的"sitepackages"目录，然后在你的代码里它们可以从任意地方导入。

"site-packages"目录中的模块，顾名思义是站点级封装。需要site-packages的应用是不可移植的，除非这些模块是单独安装的。在"site-packages" 中有模块的优势是多个应用可以共享它们。例如，让我们考虑一下，称为“matplotlib”的绘图软件包。你可以采用PEAK easy_install命令从shell安装它： ``easy_install`` command:
``
easy_install py-matplotlib
``:code

然后你就可以使用如下代码将其导入到任何模型/控制器/视图：
``
import matplotlib
``:code

web2py源代码发布和Windows二进制发布包在顶级文件夹中有site-packages。 Mac二进制发布版在如下文件夹中有site-packages文件夹：

``web2py.app/Contents/Resources/site-packages``:code

使用site-packages的问题是，难以在同一时间使用不同版本的单个模块，例如可以有两个应用，但每一个使用不同版本的同一个文件。在这个例子中，``sys.path``不能被改变，因为它会影响这两个应用。

对于这种情况，web2py 提供了另一种方式来导入模块，这样的方式没有改变全局``sys.path``：将它们放置在应用的"modules"文件夹中。一个附带的好处是，该模块将自动与应用一起复制和发布。

------
一旦模块“mymodule.py”被放置到应用的"modules/"文件夹，在web2py应用内，可以从任何地方导入它（无需改变``sys.path``）：
``
import mymodule
``
------

### 执行环境
``exec_environment``:inxx

-----
虽然这里所讨论的一切工作正常，我们建议使用在第12章介绍的组件来构建你的应用。
-----

 web2py模型和控制器文件不是Python模块，因而不能使用Python的``import``语句导入它们。这样做的原因是，模型和控制器设计来在一个预先准备好的环境中执行，该环境已预先填充了web2py全局对象（请求，响应，会话，缓存和T）及帮助对象函数。这是必要的因为Python是一种静态（词汇）范围内的语言，而web2py环境是动态创建的。 

web2py提供``exec_environment``函数让你直接访问模型和控制器。``exec_environment``创建了一个web2py执行环境，将文件加载到它然后返回一个包含环境的Storage 存储对象。Storage对象也可作为一个命名空间机制。在执行环境中执行任何Python 文件可以使用``exec_environment``加载。
``exec_environment``的用途包括：

- 从其它应用访问数据（模型）。
- 从其它模型或控制器访问全局变量。
- 从其它控制器执行控制器函数。
- 加载站点范围内的辅助库。

这个例子读取``cas``应用``user`` 表中的行：
``
from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)
``:code

另外一个例子：假设你有一个控制器“other.py”，其中包含：
``
def some_action():
    return dict(remote_addr=request.env.remote_addr)
``:code

下面是你如何可以从另一个控制器调用这个动作（或从web2py的shell）：
``
from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()
``:code

在第2行``request=request``是可选的。它的效果是将当前请求传递到"other"环境中。如果没有这个参数，该环境将包含一个新的空（除了``request.folder``folder）请求对象。也可以传递响应和会话对象到``exec_environment``。传递请求、响应和会话对象时要小心---调用对象的修改或调用行动的编码依赖性可能会导致意想不到的副作用。
第3行中的函数调用不执行视图；它仅仅是返回字典，除非 ``response.render`` 是由“some_action”显式调用。

最后一个警告：不要不恰当地使用``exec_environment``。如果你想要其它应用中动作的结果，你应该实现一个XML-RPC API（使用web2py实现XML-RPC API几乎是微不足道的）。
不要使用 ``exec_environment``作为重定向机制;使用``redirect`` 帮助对象。

### 协作
``cooperation``:inxx

应用协作的方法有很多：
- 应用可以连接到相同数据库，从而可以共享表。数据库中的所有表由所有应用程序定义是没有必要的，但它们必须被那些使用它们的应用定义。所有使用相同表
的应用，必须有一个用``migrate=False``定义表。
- 应用可以使用LOAD帮助对象嵌入来自其它应用的组件（第12章中介绍）。
- 应用可以共享会话。
- 应用可以通过XML-RPC远程调用对方的动作。
- 通过文件系统，应用可以访问对方的文件（假设它们共享相同的文件系统）。
- 应用可以使用``exec_environment`` 本地调用对方的动作，正如上面所讨论的。
- 应用可以使用下面的语法导入其它模块：
``
from applications.appname.modules import mymodule
``:code

-应用能导入``PYTHONPATH``搜索路径``sys.path``中的任何模块。  

应用可以使用下面的命令加载另一个应用的会话：

``
session.connect(request, response, masterapp='appname', db=db)
``:code

这里"appname"是主应用的名称，它在cookie中设置初始会话ID。``db`` 是一个到数据库的连接，该数据库包含session表（``web2py_session``）。所有共享会话的应用必须使用相同的数据库存储会话。

使用如下语句应用可以从另一个应用加载模块

``
import applications.otherapp.modules.othermodule
``:code

### 日志

Python提供了日志记录API。 web2py会提供一种配置它的机制，以便应用使用它。

在你的应用中，你可以创建一个记录器，例如在一个模型中：

``
import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)
``:code

你可以用它来记录各种重要消息

``
logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)
``:code

``logging`` 是一个标准的Python模块，在这里介绍：
``
http://docs.python.org/library/logging.html
``
字符串“web2py.app.myapp”定义一个应用级记录器。

为了使它正常工作，你需要一个记录器的配置文件。web2py在web2py根文件夹中提供了一个即“logging.example.conf”，。你需要将该文件重命名为“logging.conf”并根据需要对其进行定制。

这个文件是自己记录，所以你应该打开并阅读它。

要创建一个可配置的“myapp”应用的记录器，你必须添加myapp 到[loggers]的键列表：

``
[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp
``:code

而且你必须添加一个[logger_myapp]部分，使用[logger_welcome作为出发点。

``
[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0
``:code

"handlers"指令指定日志记录的类型，这里它将“myapp”记录日志到控制台。

### ''WSGI''（Web服务器网关接口）
``WSGI``:inxx

web2py和WSGI有一个又爱又恨的关系。我们的观点是，WSGI作为协议将Web服务器以可移植的方式连接到Web应用，我们为了这一目的使用它。 web2py中核心是一个WSGI
应用：``gluon.main.wsgibase``。一些开发人员将WSGI作为中间通信协议推到了极致并将Web应用作为一个有许多层（每层是一个WSGI中间件，独立于整个框架开发）的洋葱来开发。
web2py内部不采用这种结构。这是因为我们觉得如果用一个单一的综合层处理它们，可以更好地优化框架核心功能（处理Cookie，会话，错误，交易，调度）的处理速度和安全性。

然而，web2py允许你以三种方式（以及它们的组合）使用第三方WSGI应用和中间件：
- 你可以编辑文件“wsgihandler.py”并包括任何第三方WSGI中间件。
- 你可以将第三方WSGI中间件连接到你的应用中的任何特定动作。
- 你可以在动作中调用第三方WSGI应用。

唯一的限制是你不能使用第三方中间件更换核心web2py功能。

#### 外部中间件

考虑文件“wsgibase.py：
``
#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase
``:code

在``LOGGING``设置为``True``时，``gluon.main.wsgibase``被中间件函数``gluon.main.appfactory``包裹。 它为“httpserver.log”文件提供了日志。以类似的方式，你可以添加任何第三方中间件。我们参阅官方的WSGI文档了解更多信息。

#### 内部中间件

给定控制器中的任何动作（例如``index``）及任何第三方中间件应用（例如``MyMiddleware``，它将输出转换为大写），你可以使用web2py的装饰器将中间件应用于动作。下面是一个例子：
``
class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'
``:code

我们不能保证所有第三方中间件都能与该机制工作。

#### 调用''WSGI''应用 

从web2py动作容易调用WSGI应用是很容易的。下面是一个例子：
``
def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()
``:code

在这种情况下，``index``动作调用``test_wsgi_app``并在返回之前转移转义返回值。请注意``index`` 本身并不是WSGI 应用，它必须使用普通的web2py API （例如用``response.write``写到套接字）




